{"version":3,"file":"index-L0FtcT4b.js","sources":["../../../.yarn/cache/msgpackr-npm-1.10.0-40ff8e56d8-2f4330a5ce.zip/node_modules/msgpackr/unpack.js","../../../.yarn/cache/msgpackr-npm-1.10.0-40ff8e56d8-2f4330a5ce.zip/node_modules/msgpackr/pack.js","../../bench/serializers/index.ts"],"sourcesContent":["var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read().toString()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(property => property.toString()) // ensure that all keys are strings and that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= 8n;\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n}\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.useBigIntExtension && value < 2n**(1023n) && value > -(2n**(1023n))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42 // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & 0xffn;\n\t\t\t\t\t\t\talignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= 8n;\n\t\t\t\t\t\t} while (!((value === 0n || value === -1n) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension or set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// craete reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\t\t\n\t\tconst writeObject = checkUseRecords ? (object, safePrototype) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object,safePrototype) : writePlainObject(object,safePrototype)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048","'use strict';\n\nimport * as cbor from \"cbor-x\";\nimport * as msgpackr from 'msgpackr';\n\nimport { bench, Benchmark, BenchSuite } from \"../../src/ts/bench\";\nimport 'crypto'\nimport { randomBytes } from \"crypto\";\nimport { time } from \"console\";\n\nexport async function main() {\n    // '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17'\n    // '\\x16\\x00\\x00\\x00q\\xcf\\xc6*\\x00\\x00\\x00\\x00\\n\\x00\\xdaR\\xd7\\xc2\\xab\\xdf\\x8a\\x0776\\xfa\\x9adT?\\x14\\x88a(v'\n    // '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\'\n    // bench(\"text encoder 1\", () => {\n    //     stringToByteArray('\\x16\\x00\\x00\\x00q\\xcf\\xc6*\\x00\\x00\\x00\\x00\\n\\x00\\xdaR\\xd7\\xc2\\xab\\xdf\\x8a\\x0776\\xfa\\x9adT?\\x14\\x88a(v')\n    // })\n\n    // bench(\"text decoder 1\", () => {\n    //     byteArrayToString(aaa)\n    // })\n    // bench(\"stringToByteArray 2\", () => {\n    //     stringToByteArray('\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17')\n    // }, iterations * 10)\n\n    // bench(\"text encoder 2\", () => {\n    //     new TextEncoder().encode('\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17')\n    // }, iterations)\n\n    // let x = \"123\";\n    // let x = new Array(n).fill(7);\n    // let x = { test1ffffffffffffffffffff: 3, test2: 4, tesdf: 8 };\n    // let x = { a: 3, b: 4, c: 8 };\n    // let z = '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17'\n    // let x = stringToByteArray(z)\n    // let zz = new Uint32Array([1, 2, 3, 4, 5, 6, 7, 8])\n    // let x = [34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]\n    // let x = new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23])\n    // let x = { a: 1000, b: true, c: { d: { e: { f: 1000 } } }, z: new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]) }\n    // let x = { var1a: 4294967295, var1ab: true, var1ac: { var1ad: { var1ae: { var1af: 4294967295 } } } }\n    // let x = true\n    // let x = \"lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.\"\n\n    // let x = 4294967295;\n    // let x = 10000;\n    // let x = { a: 1, b: 2, c: { d: { e: 3 } } };\n\n    // demos(() => crypto.getRandomValues(x))\n    // demos(() => crypto.getRandomValues(new Uint8Array(100)))\n    await benchAllSerializers(() => { return { a: 1000, b: true, c: { d: { e: { f: 1000 } } }, z: new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]) } })\n    // demos(() => { return { a: 1, b: 2, c: { d: { e: 3 } } } })\n}\n\nexport class SerializerBench<T, K extends (Uint8Array | string)> extends BenchSuite {\n    encode: ((data: any) => K)\n    decode: ((bytes: K) => any)\n    data: T\n    encodedData: K\n\n    constructor(data: T, encode: ((data: any) => K), decode: ((bytes: K) => any)) {\n        super()\n        this.encode = encode\n        this.decode = decode\n        this.data = data\n        this.encodedData = encode(data)\n    }\n\n    async encoding() {\n        return this.encode(this.data)\n    }\n\n    async decoding() {\n        return this.decode(this.encodedData)\n    }\n}\n\nexport const benchAllSerializers = async <T>(makeValue: () => T) => {\n    let cborEncoder = new cbor.Encoder()\n    let msgpackEncoder = new msgpackr.Encoder()\n    let cborStructuredCloneEncoder = new cbor.Encoder({ structuredClone: true })\n    let msgpackStructuredCloneEncoder = new msgpackr.Encoder({ structuredClone: true })\n    let cborStructuredCloneRecordEncoder = new cbor.Encoder({ structuredClone: true, useRecords: true })\n    let msgpackStructuredCloneRecordEncoder = new msgpackr.Encoder({ structuredClone: true, useRecords: true })\n    let cborStructuredCloneStructuresEncoder = new cbor.Encoder({ structuredClone: true, structures: [] })\n    let cborStructuredCloneRecordStructuresEncoder = new cbor.Encoder({ structuredClone: true, structures: [], useRecords: true })\n    let cborRecordStructuresEncoder = new cbor.Encoder({ structures: [], useRecords: true })\n    let msgpackStructuredCloneStructuresEncoder = new msgpackr.Encoder({ structuredClone: true, structures: [] })\n    let msgpackStructuredCloneRecordStructuresEncoder = new msgpackr.Encoder({ structuredClone: true, structures: [], useRecords: true })\n    let msgpackRecordStructuresEncoder = new msgpackr.Encoder({ structures: [], useRecords: true })\n\n    let values: T[] = new Array<T>()\n\n    await new SerializerBench(makeValue(), JSON.stringify, JSON.parse).run({ name: \"JSON\" })\n    await new SerializerBench(makeValue(), cborEncoder.encode.bind(cborEncoder), cborEncoder.decode.bind(cborEncoder)).run({ name: \"CBOR\" })\n    await new SerializerBench(makeValue(), msgpackEncoder.encode.bind(msgpackEncoder), msgpackEncoder.decode.bind(msgpackEncoder)).run({ name: \"MSGPack\" })\n\n    // console.log(await bench(x.encoding, { this: x }))\n    // console.log(await bench(x.encoding.bind(x)))\n\n    // await benchSerializer(\"JSON\", values, makeValue, JSON.stringify, JSON.parse)\n\n    // await benchSerializer(\"CBOR\", values, makeValue, cborEncoder.encode.bind(cborEncoder), cborEncoder.decode.bind(cborEncoder))\n\n    // await benchSerializer(\"CBOR - structured clone\", values, makeValue, cborStructuredCloneEncoder.encode.bind(cborStructuredCloneEncoder), cborStructuredCloneEncoder.decode.bind(cborStructuredCloneEncoder))\n\n    // // benchSerializer(\"CBOR - structured clone + record\", values, makeValue, cborStructuredCloneRecordEncoder.encode.bind(cborStructuredCloneRecordEncoder), cborStructuredCloneRecordEncoder.decode.bind(cborStructuredCloneRecordEncoder))\n\n    // // benchSerializer(\"CBOR - structured clone + structures\", values, makeValue, cborStructuredCloneStructuresEncoder.encode.bind(cborStructuredCloneStructuresEncoder), cborStructuredCloneStructuresEncoder.decode.bind(cborStructuredCloneStructuresEncoder))\n\n    // benchSerializer(\"CBOR - structured clone + record + structures\", values, makeValue, cborStructuredCloneRecordStructuresEncoder.encode.bind(cborStructuredCloneRecordStructuresEncoder), cborStructuredCloneRecordStructuresEncoder.decode.bind(cborStructuredCloneRecordStructuresEncoder))\n    // benchSerializer(\"CBOR - record + structures\", values, makeValue, cborRecordStructuresEncoder.encode.bind(cborRecordStructuresEncoder), cborRecordStructuresEncoder.decode.bind(cborRecordStructuresEncoder))\n\n    // // benchSerializer(\"MSGPack\", values, makeValue, msgpackEncoder.encode.bind(msgpackEncoder), msgpackEncoder.decode.bind(msgpackEncoder))\n\n    // benchSerializer(\"MSGPack - structured clone\", values, makeValue, msgpackStructuredCloneEncoder.encode.bind(msgpackStructuredCloneEncoder), msgpackStructuredCloneEncoder.decode.bind(msgpackStructuredCloneEncoder))\n\n    // // benchSerializer(\"MSGPack - structured clone + record\", values, makeValue, msgpackStructuredCloneRecordEncoder.encode.bind(msgpackStructuredCloneRecordEncoder), msgpackStructuredCloneRecordEncoder.decode.bind(msgpackStructuredCloneRecordEncoder))\n\n    // // benchSerializer(\"MSGPack - structured clone + structures\", values, makeValue, msgpackStructuredCloneStructuresEncoder.encode.bind(msgpackStructuredCloneStructuresEncoder), msgpackStructuredCloneStructuresEncoder.decode.bind(msgpackStructuredCloneStructuresEncoder))\n    // benchSerializer(\"MSGPack - structured clone + record + structures\", values, makeValue, msgpackStructuredCloneRecordStructuresEncoder.encode.bind(msgpackStructuredCloneRecordStructuresEncoder), msgpackStructuredCloneRecordStructuresEncoder.decode.bind(msgpackStructuredCloneRecordStructuresEncoder))\n    // benchSerializer(\"MSGPack - record + structures\", values, makeValue, msgpackRecordStructuresEncoder.encode.bind(msgpackRecordStructuresEncoder), msgpackRecordStructuresEncoder.decode.bind(msgpackRecordStructuresEncoder))\n    // benchSerializer(\"BSON\", x, BSON.serialize, BSON.deserialize)\n    // benchSerializer(\"EJSON\", x, toBytesFn(EJSON.stringify), EJSON.deserialize)\n}\n\nlet benchSerializer = async <T, K extends (Uint8Array | string)>(name: string, values: T[], makeValue: () => T, encode: ((data: any) => K), decode: ((bytes: K) => any)) => {\n    try {\n        let data = makeValue();\n        let encodedData = encode(data);\n        let decodedData = decode(encodedData);\n\n        var encodedDataString: string;\n        var encodedDataBytes: Uint8Array;\n\n        switch (encodedData.constructor) {\n            case Uint8Array:\n                encodedDataBytes = encodedData as Uint8Array\n                encodedDataString = byteArrayToString(encodedDataBytes)\n                break;\n            case String:\n                encodedDataString = encodedData as string\n                encodedDataBytes = stringToByteArray(encodedDataString)\n                break;\n        }\n\n        let encodedValues: K[] = [];\n\n        await bench((B) => {\n            // B.StopTimer()\n            // makeValue();\n            // B.StartTimer()\n            encode(data);\n        }, { name: `${name} - encode fixed` })\n\n        // await bench((B) => {\n        //     // B.StopTimer()\n        //     // encode(makeValue());\n        //     // B.StartTimer()\n\n        //     decode(encodedData);\n        // }, { name: `${name} - decode fixed` })\n\n        // await bench((B) => {\n        //     B.StopTimer()\n        //     let data = makeValue();\n        //     B.StartTimer()\n\n        //     encode(data);\n        // }, {\n        //     name: `${name} - encode unique`,\n        //     setupFn: (B) => {\n        //         // if (!values[B.I]) {\n        //         //     values[B.I] = makeValue()\n        //         // }\n        //     }\n        // },)\n\n\n        // await bench((B) => {\n        //     B.StopTimer()\n        //     let data = encode(makeValue());\n        //     B.StartTimer()\n\n        //     decode(data);\n        // }, {\n        //     name: `${name} - decode unique`,\n        //     setupFn: (B) => {\n        //         // if (!values[B.I]) {\n        //         //     values[B.I] = makeValue()\n        //         // }\n\n        //         // if (!encodedValues[B.I]) {\n        //         //     encodedValues[B.I] = encode(values[B.I])\n        //         //     decode(encodedValues[B.I])\n        //         // }\n        //     }\n        // })\n\n        // console.log(`${res.name}\\t${res.N.toLocaleString()} iterations\\t${Math.round(1000 * res.N / res.duration).toLocaleString()} ops/sec`)\n\n    } catch (error) {\n        console.error(error)\n    }\n}\n\nfunction table(...benches: Benchmark[]) {\n    console.table(benches.map(b => {\n        return {\n            name: b.name,\n            \"ops/sec\": Math.round(1000 * b.N / b.duration).toLocaleString(),\n        }\n    }))\n}\n\n\nfunction toBytesFn(fn: (data: any) => string) {\n    // return (data: any) => new TextEncoder().encode(fn(data))\n    return (data: any) => stringToByteArray(fn(data))\n}\n\nfunction fromBytesFn(fn: (data: string) => any) {\n    // return (bytes: Uint8Array) => fn(new TextDecoder().decode(bytes))\n    return (bytes: Uint8Array) => fn(byteArrayToString(bytes))\n}\n\nfunction stringToByteArray(str: string) {\n    const byteArray = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        byteArray[i] = str.charCodeAt(i);\n    }\n\n    return byteArray;\n}\n\nfunction byteArrayToString(bytes: Uint8Array) {\n    return String.fromCharCode(...bytes)\n}\n\n// function stringToByteArray2(str: string) {\n//     return new TextEncoder().encode(str)\n// }\n\n// let textEncoder = new TextEncoder()\n// function stringToByteArray3(str: string) {\n//     return textEncoder.encode(str)\n// }\n\n\n// function byteArrayToString2(bytes: Uint8Array) {\n//     return new TextDecoder().decode(bytes)\n// }\n\n\n// let textDecoder = new TextDecoder()\n// function byteArrayToString3(bytes: Uint8Array) {\n//     return textDecoder.decode(bytes)\n// }\n\n"],"names":["decoder","src","srcEnd","position","currentUnpackr","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","dataView","defaultOptions","C1Type","C1","sequentialMode","inlineObjectReadThreshold","readStruct","Unpackr","options","source","saveState","clearSource","error","checkedRead","forEach","values","lastPosition","size","value","defaultUnpackr","loadedStructures","existingStructures","structure","i","l","id","existing","sharedLength","result","read","restoreStructures","jsonView","_","token","loadStructures","createStructureReader","object","key","readKey","map","array","length","string","shortStringInJS","longStringInJS","readFixedString","readBin","readExt","multiplier","mult10","recordDefinition","extension","readString8","readString16","readString32","readArray","readMap","validName","firstId","readObject","createSecondByteReader","read0","highByte","readStringJS","end","units","byte1","byte2","byte3","byte4","unit","fromCharCode","start","bytes","byte","a","b","c","d","e","f","g","h","j","k","m","n","o","readOnlyJSString","type","readPosition","keyCache","entry","checkPosition","chunk","property","firstByte","existingStructure","data","errors","target","refEntry","targetProperties","typedArrays","glbl","typeCode","typedArrayName","TEMP_BUNDLE","dataSize","dataPosition","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedStructuresContents","savedPackr","savedSequentialMode","f32Array","textEncoder","extensions","extensionClasses","hasNodeBuffer","ByteArrayAllocate","ByteArray","MAX_BUFFER_SIZE","keysTarget","targetView","safeEnd","writeStructSlots","MAX_BUNDLE_SIZE","hasNonLatin","RECORD_SYMBOL","Packr","hasSharedUpdate","structures","encodeUtf8","packr","isSequential","hasSharedStructures","maxSharedStructures","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","encodeOptions","RESERVE_START_SPACE","keys","nextTransition","transition","encodingError","writeStruct","pack","lastBundle","writeBundles","idsToInsert","incrementPosition","insertionPoint","makeRoom","serialized","insertIds","REUSE_BUFFER_MODE","resetStructures","returnBuffer","newSharedData","prepareStructures","RESET_BUFFER_MODE","packArray","strLength","extStart","maxBytes","twoByte","headerSize","c1","c2","strPosition","useFloat32","xShifted","referee","constructor","writeObject","entryValue","extensionClass","writeResult","currentTarget","currentTargetView","currentPosition","writeExtensionData","json","alignedSign","writePlainObject","num","safePrototype","objectOffset","writeRecord","wroteKeys","lastTransition","newTransitions","newRecord","insertNewRecord","recordId","checkUseRecords","newSize","newBuffer","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","notifySharedUpdate","startTarget","buffer","date","allocateForWrite","seconds","set","regex","arrayBuffer","writeExtBuffer","writeBuffer","typedArray","encode","nextId","distanceToMove","lastEnd","offset","writeStrings","compatible","defaultPackr","Encoder","main","benchAllSerializers","SerializerBench","BenchSuite","decode","makeValue","cborEncoder","cbor.Encoder","msgpackEncoder","msgpackr.Encoder"],"mappings":"kFAAA,IAAIA,GACJ,GAAI,CACHA,GAAU,IAAI,WACf,MAAe,CAAE,CACjB,IAAIC,EACAC,EACAC,EAAW,EAKXC,EAAiB,CAAE,EACnBC,EACAC,EACAC,EAAiB,EACjBC,EAAe,EACfC,EACAC,EACAC,EAAoB,CAAE,EACtBC,EACAC,GAAiB,CACpB,WAAY,GACZ,cAAe,EAChB,EACO,MAAMC,EAAO,CAAE,CACf,MAAMC,GAAK,IAAID,GACtBC,GAAG,KAAO,mBACV,IAAIC,EAAiB,GACjBC,GAA4B,EAC5BC,GAGJ,GAAI,CACH,IAAI,SAAS,EAAE,CAChB,MAAe,CAEdD,GAA4B,GAC7B,CAEO,MAAME,EAAQ,CACpB,YAAYC,EAAS,CAChBA,IACCA,EAAQ,aAAe,IAASA,EAAQ,gBAAkB,SAC7DA,EAAQ,cAAgB,IACrBA,EAAQ,YAAcA,EAAQ,UAAY,KAC7CA,EAAQ,QAAU,GACd,CAACA,EAAQ,YAAcA,EAAQ,YAAc,KAChDA,EAAQ,WAAa,CAAE,EAClBA,EAAQ,sBACZA,EAAQ,oBAAsB,KAG7BA,EAAQ,WACXA,EAAQ,WAAW,aAAeA,EAAQ,WAAW,OAC7CA,EAAQ,iBACfA,EAAQ,WAAa,CAAE,GAAE,cAAgB,GAC1CA,EAAQ,WAAW,aAAe,GAE/BA,EAAQ,gBACXA,EAAQ,YAAc,WAGxB,OAAO,OAAO,KAAMA,CAAO,CAC3B,CACD,OAAOC,EAAQD,EAAS,CACvB,GAAInB,EAEH,OAAOqB,GAAU,KAChBC,GAAa,EACN,KAAO,KAAK,OAAOF,EAAQD,CAAO,EAAID,GAAQ,UAAU,OAAO,KAAKN,GAAgBQ,EAAQD,CAAO,EAC1G,EAEE,CAACC,EAAO,QAAUA,EAAO,cAAgB,cAC5CA,EAAS,OAAO,OAAW,IAAc,OAAO,KAAKA,CAAM,EAAI,IAAI,WAAWA,CAAM,GACjF,OAAOD,GAAY,UACtBlB,EAASkB,EAAQ,KAAOC,EAAO,OAC/BlB,EAAWiB,EAAQ,OAAS,IAE5BjB,EAAW,EACXD,EAASkB,EAAU,GAAKA,EAAUC,EAAO,QAG1Cb,EAAe,EACfF,EAAY,KAEZG,EAAiB,KACjBR,EAAMoB,EAIN,GAAI,CACHT,EAAWS,EAAO,WAAaA,EAAO,SAAW,IAAI,SAASA,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EACjH,OAAOG,EAAO,CAGd,MADAvB,EAAM,KACFoB,aAAkB,WACfG,EACD,IAAI,MAAM,oDAAuDH,GAAU,OAAOA,GAAU,SAAYA,EAAO,YAAY,KAAO,OAAOA,EAAO,CACtJ,CACD,GAAI,gBAAgBF,GAAS,CAE5B,GADAf,EAAiB,KACb,KAAK,WACR,OAAAC,EAAoB,KAAK,WAClBoB,GAAYL,CAAO,GAChB,CAACf,GAAqBA,EAAkB,OAAS,KAC3DA,EAAoB,CAAE,EAE1B,MACGD,EAAiBS,IACb,CAACR,GAAqBA,EAAkB,OAAS,KACpDA,EAAoB,CAAE,GAExB,OAAOoB,GAAYL,CAAO,CAC1B,CACD,eAAeC,EAAQK,EAAS,CAC/B,IAAIC,EAAQC,EAAe,EAC3B,GAAI,CACHZ,EAAiB,GACjB,IAAIa,EAAOR,EAAO,OACdS,EAAQ,KAAO,KAAK,OAAOT,EAAQQ,CAAI,EAAIE,GAAe,OAAOV,EAAQQ,CAAI,EACjF,GAAIH,EAAS,CACZ,GAAIA,EAAQI,EAAOF,EAAczB,CAAQ,IAAM,GAAO,OACtD,KAAMA,EAAW0B,GAEhB,GADAD,EAAezB,EACXuB,EAAQD,GAAa,EAAEG,EAAczB,CAAQ,IAAM,GACtD,MAGF,KACI,CAEJ,IADAwB,EAAS,CAAEG,CAAO,EACZ3B,EAAW0B,GAChBD,EAAezB,EACfwB,EAAO,KAAKF,IAAa,EAE1B,OAAOE,CACP,CACD,OAAOH,EAAO,CACd,MAAAA,EAAM,aAAeI,EACrBJ,EAAM,OAASG,EACTH,CACT,QAAY,CACTR,EAAiB,GACjBO,GAAa,CACb,CACD,CACD,iBAAiBS,EAAkBC,EAAoB,CAGtDD,EAAmBA,GAAoB,CAAE,EACrC,OAAO,SAASA,CAAgB,IACnCA,EAAmBA,EAAiB,IAAIE,GAAaA,EAAU,MAAM,CAAC,CAAC,GACxE,QAASC,EAAI,EAAGC,EAAIJ,EAAiB,OAAQG,EAAIC,EAAGD,IAAK,CACxD,IAAID,EAAYF,EAAiBG,CAAC,EAC9BD,IACHA,EAAU,SAAW,GACjBC,GAAK,KACRD,EAAU,SAAYC,EAAI,IAAO,GAEnC,CACDH,EAAiB,aAAeA,EAAiB,OACjD,QAASK,KAAMJ,GAAsB,GACpC,GAAII,GAAM,EAAG,CACZ,IAAIH,EAAYF,EAAiBK,CAAE,EAC/BC,EAAWL,EAAmBI,CAAE,EAChCC,IACCJ,KACFF,EAAiB,oBAAsBA,EAAiB,kBAAoB,KAAKK,CAAE,EAAIH,GACzFF,EAAiBK,CAAE,EAAIC,EAExB,CAEF,OAAO,KAAK,WAAaN,CACzB,CACD,OAAOX,EAAQD,EAAS,CACvB,OAAO,KAAK,OAAOC,EAAQD,CAAO,CAClC,CACF,CAIO,SAASK,GAAYL,EAAS,CACpC,GAAI,CACH,GAAI,CAAChB,EAAe,SAAW,CAACY,EAAgB,CAC/C,IAAIuB,EAAelC,EAAkB,cAAgB,EACjDkC,EAAelC,EAAkB,SACpCA,EAAkB,OAASkC,EAC5B,CACD,IAAIC,EAkBJ,GAjBIpC,EAAe,uBAAyBH,EAAIE,CAAQ,EAAI,IAAQF,EAAIE,CAAQ,GAAK,IAAQe,IAC5FsB,EAAStB,GAAWjB,EAAKE,EAAUD,EAAQE,CAAc,EACzDH,EAAM,KACF,EAAEmB,GAAWA,EAAQ,OAASoB,IACjCA,EAASA,EAAO,OAAQ,GACzBrC,EAAWD,GAEXsC,EAASC,EAAM,EACZhC,IACHN,EAAWM,EAAe,mBAC1BA,EAAiB,MAEdO,IAGHX,EAAkB,kBAAoB,MAEnCF,GAAYD,EAEXG,GAAqBA,EAAkB,mBAC1CqC,GAAmB,EACpBrC,EAAoB,KACpBJ,EAAM,KACFS,IACHA,EAAe,UACV,IAAIP,EAAWD,EAErB,MAAM,IAAI,MAAM,oCAAoC,EAC9C,GAAI,CAACc,EAAgB,CAC3B,IAAI2B,EACJ,GAAI,CACHA,EAAW,KAAK,UAAUH,EAAQ,CAACI,EAAGd,IAAU,OAAOA,GAAU,SAAW,GAAGA,CAAK,IAAMA,CAAK,EAAE,MAAM,EAAG,GAAG,CAC7G,OAAON,EAAO,CACdmB,EAAW,4BAA8BnB,EAAQ,GACjD,CACD,MAAM,IAAI,MAAM,4CAA8CmB,CAAQ,CACtE,EAED,OAAOH,CACP,OAAOhB,EAAO,CACd,MAAInB,GAAqBA,EAAkB,mBAC1CqC,GAAmB,EACpBnB,GAAa,GACTC,aAAiB,YAAcA,EAAM,QAAQ,WAAW,0BAA0B,GAAKrB,EAAWD,KACrGsB,EAAM,WAAa,IAEdA,CACN,CACF,CAEA,SAASkB,IAAoB,CAC5B,QAASL,KAAMhC,EAAkB,kBAChCA,EAAkBgC,CAAE,EAAIhC,EAAkB,kBAAkBgC,CAAE,EAE/DhC,EAAkB,kBAAoB,IACvC,CAEO,SAASoC,GAAO,CACtB,IAAII,EAAQ5C,EAAIE,GAAU,EAC1B,GAAI0C,EAAQ,IACX,GAAIA,EAAQ,IAAM,CACjB,GAAIA,EAAQ,GACX,OAAOA,EACH,CACJ,IAAIX,EAAY7B,EAAkBwC,EAAQ,EAAI,GAC7CzC,EAAe,eAAiB0C,KAAiBD,EAAQ,EAAI,EAC9D,OAAIX,GACEA,EAAU,OACdA,EAAU,KAAOa,GAAsBb,EAAWW,EAAQ,EAAI,GAExDX,EAAU,KAAM,GAEhBW,CACR,CACJ,SAAaA,EAAQ,IAGlB,GADAA,GAAS,IACLzC,EAAe,cAAe,CACjC,IAAI4C,EAAS,CAAE,EACf,QAASb,EAAI,EAAGA,EAAIU,EAAOV,IAAK,CAC/B,IAAIc,EAAMC,GAAS,EACfD,IAAQ,cACXA,EAAM,YACPD,EAAOC,CAAG,EAAIR,EAAM,CACpB,CACD,OAAOO,CACX,KAAU,CACN,IAAIG,EAAM,IAAI,IACd,QAAShB,EAAI,EAAGA,EAAIU,EAAOV,IAC1BgB,EAAI,IAAIV,EAAM,EAAEA,EAAI,CAAE,EAEvB,OAAOU,CACP,KACK,CACNN,GAAS,IACT,IAAIO,EAAQ,IAAI,MAAMP,CAAK,EAC3B,QAASV,EAAI,EAAGA,EAAIU,EAAOV,IAC1BiB,EAAMjB,CAAC,EAAIM,EAAM,EAElB,OAAIrC,EAAe,WACX,OAAO,OAAOgD,CAAK,EACpBA,CACP,SACSP,EAAQ,IAAM,CAExB,IAAIQ,EAASR,EAAQ,IACrB,GAAIrC,GAAgBL,EACnB,OAAOG,EAAU,MAAMH,EAAWI,GAAiBJ,GAAYkD,GAAU9C,CAAc,EAExF,GAAIC,GAAgB,GAAKN,EAAS,IAAK,CAEtC,IAAIoD,EAASD,EAAS,GAAKE,GAAgBF,CAAM,EAAIG,GAAeH,CAAM,EAC1E,GAAIC,GAAU,KACb,OAAOA,CACR,CACD,OAAOG,GAAgBJ,CAAM,CAC/B,KAAQ,CACN,IAAIvB,EACJ,OAAQe,EAAK,CACZ,IAAK,KAAM,OAAO,KAClB,IAAK,KACJ,OAAIpC,GACHqB,EAAQW,EAAM,EACVX,EAAQ,EACJrB,EAAe,CAAC,EAAE,MAAMA,EAAe,UAAWA,EAAe,WAAaqB,CAAK,EAEnFrB,EAAe,CAAC,EAAE,MAAMA,EAAe,UAAWA,EAAe,WAAaqB,CAAK,GAErFf,GACR,IAAK,KAAM,MAAO,GAClB,IAAK,KAAM,MAAO,GAClB,IAAK,KAGJ,GADAe,EAAQ7B,EAAIE,GAAU,EAClB2B,IAAU,OACb,MAAM,IAAI,MAAM,0BAA0B,EAC3C,OAAO4B,GAAQ5B,CAAK,EACrB,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLuD,GAAQ5B,CAAK,EACrB,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLuD,GAAQ5B,CAAK,EACrB,IAAK,KAEJ,OAAO6B,EAAQ1D,EAAIE,GAAU,CAAC,EAC/B,IAAK,KAEJ,OAAA2B,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLwD,EAAQ7B,CAAK,EACrB,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLwD,EAAQ7B,CAAK,EACrB,IAAK,KAEJ,GADAA,EAAQlB,EAAS,WAAWT,CAAQ,EAChCC,EAAe,WAAa,EAAG,CAElC,IAAIwD,EAAaC,IAAS5D,EAAIE,CAAQ,EAAI,MAAS,EAAMF,EAAIE,EAAW,CAAC,GAAK,CAAE,EAChFA,OAAAA,GAAY,GACHyD,EAAa9B,GAASA,EAAQ,EAAI,GAAM,MAAU,GAAK8B,CAChE,CACDzD,OAAAA,GAAY,EACL2B,EACR,IAAK,KACJ,OAAAA,EAAQlB,EAAS,WAAWT,CAAQ,EACpCA,GAAY,EACL2B,EAER,IAAK,KACJ,OAAO7B,EAAIE,GAAU,EACtB,IAAK,KACJ,OAAA2B,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACL2B,EACR,IAAK,KACJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACL2B,EACR,IAAK,KACJ,OAAI1B,EAAe,cAAgB,UAClC0B,EAAQlB,EAAS,UAAUT,CAAQ,EAAI,WACvC2B,GAASlB,EAAS,UAAUT,EAAW,CAAC,GAC9BC,EAAe,cAAgB,SACzC0B,EAAQlB,EAAS,aAAaT,CAAQ,EAAE,SAAU,EACxCC,EAAe,cAAgB,QACzC0B,EAAQlB,EAAS,aAAaT,CAAQ,EAClC2B,GAAO,OAAO,CAAC,GAAG,OAAO,EAAE,IAAGA,EAAM,OAAOA,CAAK,IAEpDA,EAAQlB,EAAS,aAAaT,CAAQ,EACvCA,GAAY,EACL2B,EAGR,IAAK,KACJ,OAAOlB,EAAS,QAAQT,GAAU,EACnC,IAAK,KACJ,OAAA2B,EAAQlB,EAAS,SAAST,CAAQ,EAClCA,GAAY,EACL2B,EACR,IAAK,KACJ,OAAAA,EAAQlB,EAAS,SAAST,CAAQ,EAClCA,GAAY,EACL2B,EACR,IAAK,KACJ,OAAI1B,EAAe,cAAgB,UAClC0B,EAAQlB,EAAS,SAAST,CAAQ,EAAI,WACtC2B,GAASlB,EAAS,UAAUT,EAAW,CAAC,GAC9BC,EAAe,cAAgB,SACzC0B,EAAQlB,EAAS,YAAYT,CAAQ,EAAE,SAAU,EACvCC,EAAe,cAAgB,QACzC0B,EAAQlB,EAAS,YAAYT,CAAQ,EACjC2B,GAAO,OAAO,EAAE,GAAG,OAAO,EAAE,GAAGA,GAAO,OAAO,CAAC,GAAG,OAAO,EAAE,IAAGA,EAAM,OAAOA,CAAK,IAEnFA,EAAQlB,EAAS,YAAYT,CAAQ,EACtCA,GAAY,EACL2B,EAER,IAAK,KAGJ,GADAA,EAAQ7B,EAAIE,GAAU,EAClB2B,GAAS,IACZ,OAAOgC,GAAiB7D,EAAIE,GAAU,EAAI,EAAI,EACxC,CACN,IAAI4D,EAAYpD,EAAkBmB,CAAK,EACvC,GAAIiC,EACH,OAAIA,EAAU,MACb5D,IACO4D,EAAU,KAAKtB,GAAM,GAClBsB,EAAU,UACpB5D,IACO4D,EAAW,GAEXA,EAAU9D,EAAI,SAASE,EAAU,EAAEA,CAAQ,CAAC,EAEpD,MAAM,IAAI,MAAM,qBAAuB2B,CAAK,CAC7C,CACF,IAAK,KAGJ,OADAA,EAAQ7B,EAAIE,CAAQ,EAChB2B,GAAS,KACZ3B,IACO2D,GAAiB7D,EAAIE,GAAU,EAAI,GAAMF,EAAIE,GAAU,CAAC,GAExDwD,EAAQ,CAAC,EAClB,IAAK,KAEJ,OAAOA,EAAQ,CAAC,EACjB,IAAK,KAEJ,OAAOA,EAAQ,CAAC,EACjB,IAAK,KAEJ,OAAOA,EAAQ,EAAE,EAClB,IAAK,KAGJ,OADA7B,EAAQ7B,EAAIE,GAAU,EAClBK,GAAgBL,EACZG,EAAU,MAAMH,EAAWI,GAAiBJ,GAAY2B,GAASvB,CAAc,EAEhFyD,GAAYlC,CAAK,EACzB,IAAK,KAIJ,OAFAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACRK,GAAgBL,EACZG,EAAU,MAAMH,EAAWI,GAAiBJ,GAAY2B,GAASvB,CAAc,EAEhF0D,GAAanC,CAAK,EAC1B,IAAK,KAIJ,OAFAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACRK,GAAgBL,EACZG,EAAU,MAAMH,EAAWI,GAAiBJ,GAAY2B,GAASvB,CAAc,EAEhF2D,GAAapC,CAAK,EAC1B,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLgE,GAAUrC,CAAK,EACvB,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLgE,GAAUrC,CAAK,EACvB,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLiE,GAAQtC,CAAK,EACrB,IAAK,KAEJ,OAAAA,EAAQlB,EAAS,UAAUT,CAAQ,EACnCA,GAAY,EACLiE,GAAQtC,CAAK,EACrB,QACC,GAAIe,GAAS,IACZ,OAAOA,EAAQ,IAChB,GAAIA,IAAU,OAAW,CACxB,IAAIrB,EAAQ,IAAI,MAAM,oCAAoC,EAC1D,MAAAA,EAAM,WAAa,GACbA,CACN,CACD,MAAM,IAAI,MAAM,6BAA+BqB,CAAK,CAErD,CACD,CACF,CACA,MAAMwB,GAAY,4BAClB,SAAStB,GAAsBb,EAAWoC,EAAS,CAClD,SAASC,GAAa,CAErB,GAAIA,EAAW,QAAUtD,GAA2B,CACnD,IAAIsD,EAAarC,EAAU,KAAQ,IAAI,SAAS,IAAK,6BAA+B9B,EAAe,WAAa,gBAAkB,IACjI,KAAO8B,EAAU,IAAIe,GAAOA,IAAQ,YAAc,eAAiBoB,GAAU,KAAKpB,CAAG,EAAIA,EAAM,OAAU,IAAM,KAAK,UAAUA,CAAG,EAAI,OAAQ,EAAE,KAAK,GAAG,EAAI,KAAK,EAAGR,CAAI,EACxK,OAAIP,EAAU,WAAa,IAC1BA,EAAU,KAAOsC,GAAuBF,EAASpC,EAAU,IAAI,GACzDqC,EAAY,CACnB,CACD,IAAIvB,EAAS,CAAE,EACf,QAASb,EAAI,EAAGC,EAAIF,EAAU,OAAQC,EAAIC,EAAGD,IAAK,CACjD,IAAIc,EAAMf,EAAUC,CAAC,EACjBc,IAAQ,cACXA,EAAM,YACPD,EAAOC,CAAG,EAAIR,EAAM,CACpB,CACD,OAAIrC,EAAe,WACX,OAAO,OAAO4C,CAAM,EACrBA,CACP,CAED,OADAuB,EAAW,MAAQ,EACfrC,EAAU,WAAa,EACnBsC,GAAuBF,EAASC,CAAU,EAE3CA,CACR,CAEA,MAAMC,GAAyB,CAACF,EAASG,IACjC,UAAW,CACjB,IAAIC,EAAWzE,EAAIE,GAAU,EAC7B,GAAIuE,IAAa,EAChB,OAAOD,EAAO,EACf,IAAIpC,EAAKiC,EAAU,GAAK,EAAEA,GAAWI,GAAY,IAAMJ,GAAWI,GAAY,GAC1ExC,EAAY7B,EAAkBgC,CAAE,GAAKS,GAAc,EAAGT,CAAE,EAC5D,GAAI,CAACH,EACJ,MAAM,IAAI,MAAM,gCAAkCG,CAAE,EAErD,OAAKH,EAAU,OACdA,EAAU,KAAOa,GAAsBb,EAAWoC,CAAO,GACnDpC,EAAU,KAAM,CACvB,EAGK,SAASY,IAAiB,CAChC,IAAId,EAAmBV,GAAU,KAEhCrB,EAAM,KACCG,EAAe,cAAe,EACrC,EACD,OAAOC,EAAoBD,EAAe,iBAAiB4B,EAAkB3B,CAAiB,CAC/F,CAEA,IAAIoD,GAAkBkB,GAClBX,GAAcW,GACdV,GAAeU,GACfT,GAAeS,GA0CnB,SAASA,GAAatB,EAAQ,CAC7B,IAAIb,EACJ,GAAIa,EAAS,KACRb,EAASe,GAAgBF,CAAM,GAClC,OAAOb,EAET,GAAIa,EAAS,IAAMrD,GAClB,OAAOA,GAAQ,OAAOC,EAAI,SAASE,EAAUA,GAAYkD,CAAM,CAAC,EACjE,MAAMuB,EAAMzE,EAAWkD,EACjBwB,EAAQ,CAAE,EAEhB,IADArC,EAAS,GACFrC,EAAWyE,GAAK,CACtB,MAAME,EAAQ7E,EAAIE,GAAU,EAC5B,GAAK,EAAA2E,EAAQ,KAEZD,EAAM,KAAKC,CAAK,WACLA,EAAQ,OAAU,IAAM,CAEnC,MAAMC,EAAQ9E,EAAIE,GAAU,EAAI,GAChC0E,EAAM,MAAOC,EAAQ,KAAS,EAAKC,CAAK,CACxC,UAAWD,EAAQ,OAAU,IAAM,CAEnC,MAAMC,EAAQ9E,EAAIE,GAAU,EAAI,GAC1B6E,EAAQ/E,EAAIE,GAAU,EAAI,GAChC0E,EAAM,MAAOC,EAAQ,KAAS,GAAOC,GAAS,EAAKC,CAAK,CACxD,UAAWF,EAAQ,OAAU,IAAM,CAEnC,MAAMC,EAAQ9E,EAAIE,GAAU,EAAI,GAC1B6E,EAAQ/E,EAAIE,GAAU,EAAI,GAC1B8E,EAAQhF,EAAIE,GAAU,EAAI,GAChC,IAAI+E,GAASJ,EAAQ,IAAS,GAASC,GAAS,GAASC,GAAS,EAAQC,EACtEC,EAAO,QACVA,GAAQ,MACRL,EAAM,KAAOK,IAAS,GAAM,KAAS,KAAM,EAC3CA,EAAO,MAAUA,EAAO,MAEzBL,EAAM,KAAKK,CAAI,CAClB,MACGL,EAAM,KAAKC,CAAK,EAGbD,EAAM,QAAU,OACnBrC,GAAU2C,EAAa,MAAM,OAAQN,CAAK,EAC1CA,EAAM,OAAS,EAEhB,CAED,OAAIA,EAAM,OAAS,IAClBrC,GAAU2C,EAAa,MAAM,OAAQN,CAAK,GAGpCrC,CACR,CAYA,SAAS2B,GAAUd,EAAQ,CAC1B,IAAID,EAAQ,IAAI,MAAMC,CAAM,EAC5B,QAASlB,EAAI,EAAGA,EAAIkB,EAAQlB,IAC3BiB,EAAMjB,CAAC,EAAIM,EAAM,EAElB,OAAIrC,EAAe,WACX,OAAO,OAAOgD,CAAK,EACpBA,CACR,CAEA,SAASgB,GAAQf,EAAQ,CACxB,GAAIjD,EAAe,cAAe,CACjC,IAAI4C,EAAS,CAAE,EACf,QAASb,EAAI,EAAGA,EAAIkB,EAAQlB,IAAK,CAChC,IAAIc,EAAMC,GAAS,EACfD,IAAQ,cACXA,EAAM,YACPD,EAAOC,CAAG,EAAIR,EAAM,CACpB,CACD,OAAOO,CACT,KAAQ,CACN,IAAIG,EAAM,IAAI,IACd,QAAShB,EAAI,EAAGA,EAAIkB,EAAQlB,IAC3BgB,EAAI,IAAIV,EAAM,EAAEA,EAAI,CAAE,EAEvB,OAAOU,CACP,CACF,CAEA,IAAIgC,EAAe,OAAO,aAC1B,SAAS3B,GAAeH,EAAQ,CAC/B,IAAI+B,EAAQjF,EACRkF,EAAQ,IAAI,MAAMhC,CAAM,EAC5B,QAASlB,EAAI,EAAGA,EAAIkB,EAAQlB,IAAK,CAChC,MAAMmD,EAAOrF,EAAIE,GAAU,EAC3B,IAAKmF,EAAO,KAAQ,EAAG,CACrBnF,EAAWiF,EACX,MACA,CACDC,EAAMlD,CAAC,EAAImD,CACX,CACD,OAAOH,EAAa,MAAM,OAAQE,CAAK,CACzC,CACA,SAAS9B,GAAgBF,EAAQ,CAChC,GAAIA,EAAS,EACZ,GAAIA,EAAS,EAAG,CACf,GAAIA,IAAW,EACd,MAAO,GACH,CACJ,IAAIkC,EAAItF,EAAIE,GAAU,EACtB,IAAKoF,EAAI,KAAQ,EAAG,CACnBpF,GAAY,EACZ,MACA,CACD,OAAOgF,EAAaI,CAAC,CACrB,CACJ,KAAS,CACN,IAAIA,EAAItF,EAAIE,GAAU,EAClBqF,EAAIvF,EAAIE,GAAU,EACtB,IAAKoF,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACrCrF,GAAY,EACZ,MACA,CACD,GAAIkD,EAAS,EACZ,OAAO8B,EAAaI,EAAGC,CAAC,EACzB,IAAIC,EAAIxF,EAAIE,GAAU,EACtB,IAAKsF,EAAI,KAAQ,EAAG,CACnBtF,GAAY,EACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,CAAC,CAC3B,KACK,CACN,IAAIF,EAAItF,EAAIE,GAAU,EAClBqF,EAAIvF,EAAIE,GAAU,EAClBsF,EAAIxF,EAAIE,GAAU,EAClBuF,EAAIzF,EAAIE,GAAU,EACtB,IAAKoF,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACzEvF,GAAY,EACZ,MACA,CACD,GAAIkD,EAAS,EAAG,CACf,GAAIA,IAAW,EACd,OAAO8B,EAAaI,EAAGC,EAAGC,EAAGC,CAAC,EAC1B,CACJ,IAAIC,EAAI1F,EAAIE,GAAU,EACtB,IAAKwF,EAAI,KAAQ,EAAG,CACnBxF,GAAY,EACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CACjC,CACJ,SAAatC,EAAS,EAAG,CACtB,IAAIsC,EAAI1F,EAAIE,GAAU,EAClByF,EAAI3F,EAAIE,GAAU,EACtB,IAAKwF,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACrCzF,GAAY,EACZ,MACA,CACD,GAAIkD,EAAS,EACZ,OAAO8B,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,EACrC,IAAIC,EAAI5F,EAAIE,GAAU,EACtB,IAAK0F,EAAI,KAAQ,EAAG,CACnB1F,GAAY,EACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CAC1C,KAAS,CACN,IAAIF,EAAI1F,EAAIE,GAAU,EAClByF,EAAI3F,EAAIE,GAAU,EAClB0F,EAAI5F,EAAIE,GAAU,EAClB2F,EAAI7F,EAAIE,GAAU,EACtB,IAAKwF,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACzE3F,GAAY,EACZ,MACA,CACD,GAAIkD,EAAS,GAAI,CAChB,GAAIA,IAAW,EACd,OAAO8B,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,EACtC,CACJ,IAAI3D,EAAIlC,EAAIE,GAAU,EACtB,IAAKgC,EAAI,KAAQ,EAAG,CACnBhC,GAAY,EACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,CAAC,CAC7C,CACL,SAAckB,EAAS,GAAI,CACvB,IAAIlB,EAAIlC,EAAIE,GAAU,EAClB4F,EAAI9F,EAAIE,GAAU,EACtB,IAAKgC,EAAI,KAAQ,IAAM4D,EAAI,KAAQ,EAAG,CACrC5F,GAAY,GACZ,MACA,CACD,GAAIkD,EAAS,GACZ,OAAO8B,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,EAAG4D,CAAC,EACjD,IAAIC,EAAI/F,EAAIE,GAAU,EACtB,IAAK6F,EAAI,KAAQ,EAAG,CACnB7F,GAAY,GACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,EAAG4D,EAAGC,CAAC,CACvD,KAAU,CACN,IAAI7D,EAAIlC,EAAIE,GAAU,EAClB4F,EAAI9F,EAAIE,GAAU,EAClB6F,EAAI/F,EAAIE,GAAU,EAClBiC,EAAInC,EAAIE,GAAU,EACtB,IAAKgC,EAAI,KAAQ,IAAM4D,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAM5D,EAAI,KAAQ,EAAG,CACzEjC,GAAY,GACZ,MACA,CACD,GAAIkD,EAAS,GAAI,CAChB,GAAIA,IAAW,GACd,OAAO8B,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,EAAG4D,EAAGC,EAAG5D,CAAC,EAClD,CACJ,IAAI6D,EAAIhG,EAAIE,GAAU,EACtB,IAAK8F,EAAI,KAAQ,EAAG,CACnB9F,GAAY,GACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,EAAG4D,EAAGC,EAAG5D,EAAG6D,CAAC,CACzD,CACN,KAAW,CACN,IAAIA,EAAIhG,EAAIE,GAAU,EAClB+F,EAAIjG,EAAIE,GAAU,EACtB,IAAK8F,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACrC/F,GAAY,GACZ,MACA,CACD,GAAIkD,EAAS,GACZ,OAAO8B,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,EAAG4D,EAAGC,EAAG5D,EAAG6D,EAAGC,CAAC,EAC7D,IAAIC,EAAIlG,EAAIE,GAAU,EACtB,IAAKgG,EAAI,KAAQ,EAAG,CACnBhG,GAAY,GACZ,MACA,CACD,OAAOgF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG3D,EAAG4D,EAAGC,EAAG5D,EAAG6D,EAAGC,EAAGC,CAAC,CAC/D,CACD,CACD,CACD,CACF,CAEA,SAASC,IAAmB,CAC3B,IAAIvD,EAAQ5C,EAAIE,GAAU,EACtBkD,EACJ,GAAIR,EAAQ,IAEXQ,EAASR,EAAQ,QAEjB,QAAOA,EAAK,CACX,IAAK,KAEJQ,EAASpD,EAAIE,GAAU,EACvB,MACD,IAAK,KAEJkD,EAASzC,EAAS,UAAUT,CAAQ,EACpCA,GAAY,EACZ,MACD,IAAK,KAEJkD,EAASzC,EAAS,UAAUT,CAAQ,EACpCA,GAAY,EACZ,MACD,QACC,MAAM,IAAI,MAAM,iBAAiB,CAClC,CAEF,OAAOwE,GAAatB,CAAM,CAC3B,CAGA,SAASK,GAAQL,EAAQ,CACxB,OAAOjD,EAAe,YAErB,WAAW,UAAU,MAAM,KAAKH,EAAKE,EAAUA,GAAYkD,CAAM,EACjEpD,EAAI,SAASE,EAAUA,GAAYkD,CAAM,CAC3C,CACA,SAASM,EAAQN,EAAQ,CACxB,IAAIgD,EAAOpG,EAAIE,GAAU,EACzB,GAAIQ,EAAkB0F,CAAI,EAAG,CAC5B,IAAIzB,EACJ,OAAOjE,EAAkB0F,CAAI,EAAEpG,EAAI,SAASE,EAAUyE,EAAOzE,GAAYkD,CAAO,EAAIiD,GAAiB,CACpGnG,EAAWmG,EACX,GAAI,CACH,OAAO7D,EAAI,CACf,QAAa,CACTtC,EAAWyE,CACX,CACJ,CAAG,CACD,KAEA,OAAM,IAAI,MAAM,0BAA4ByB,CAAI,CAClD,CAEA,IAAIE,GAAW,IAAI,MAAM,IAAI,EAC7B,SAASrD,IAAU,CAClB,IAAIG,EAASpD,EAAIE,GAAU,EAC3B,GAAIkD,GAAU,KAAQA,EAAS,IAAM,CAGpC,GADAA,EAASA,EAAS,IACd7C,GAAgBL,EACnB,OAAOG,EAAU,MAAMH,EAAWI,GAAiBJ,GAAYkD,GAAU9C,CAAc,EACnF,GAAI,EAAEC,GAAgB,GAAKN,EAAS,KACxC,OAAOuD,GAAgBJ,CAAM,CAChC,KACElD,QAAAA,IACOsC,EAAM,EAAC,SAAU,EAEzB,IAAIQ,GAAQI,GAAU,GAAMA,EAAS,EAAIzC,EAAS,UAAUT,CAAQ,EAAIkD,EAAS,EAAIpD,EAAIE,CAAQ,EAAI,IAAM,KACvGqG,EAAQD,GAAStD,CAAG,EACpBwD,EAAgBtG,EAChByE,EAAMzE,EAAWkD,EAAS,EAC1BqD,EACAvE,EAAI,EACR,GAAIqE,GAASA,EAAM,OAASnD,EAAQ,CACnC,KAAOoD,EAAgB7B,GAAK,CAE3B,GADA8B,EAAQ9F,EAAS,UAAU6F,CAAa,EACpCC,GAASF,EAAMrE,GAAG,EAAG,CACxBsE,EAAgB,WAChB,KACA,CACDA,GAAiB,CACjB,CAED,IADA7B,GAAO,EACA6B,EAAgB7B,GAEtB,GADA8B,EAAQzG,EAAIwG,GAAe,EACvBC,GAASF,EAAMrE,GAAG,EAAG,CACxBsE,EAAgB,WAChB,KACA,CAEF,GAAIA,IAAkB7B,EACrBzE,OAAAA,EAAWsG,EACJD,EAAM,OAEd5B,GAAO,EACP6B,EAAgBtG,CAChB,CAID,IAHAqG,EAAQ,CAAE,EACVD,GAAStD,CAAG,EAAIuD,EAChBA,EAAM,MAAQnD,EACPoD,EAAgB7B,GACtB8B,EAAQ9F,EAAS,UAAU6F,CAAa,EACxCD,EAAM,KAAKE,CAAK,EAChBD,GAAiB,EAGlB,IADA7B,GAAO,EACA6B,EAAgB7B,GACtB8B,EAAQzG,EAAIwG,GAAe,EAC3BD,EAAM,KAAKE,CAAK,EAGjB,IAAIpD,EAASD,EAAS,GAAKE,GAAgBF,CAAM,EAAIG,GAAeH,CAAM,EAC1E,OAAIC,GAAU,KACNkD,EAAM,OAASlD,EAChBkD,EAAM,OAAS/C,GAAgBJ,CAAM,CAC7C,CAGA,MAAMS,GAAmB,CAACzB,EAAIqC,IAAa,CAC1C,IAAIxC,EAAYO,IAAO,IAAIkE,GAAYA,EAAS,UAAU,EACtDC,EAAYvE,EACZqC,IAAa,SAChBrC,EAAKA,EAAK,GAAK,GAAGqC,GAAY,GAAKrC,IAAQqC,GAAY,GAAKrC,EAC5DH,EAAU,SAAWwC,GAEtB,IAAImC,EAAoBxG,EAAkBgC,CAAE,EAI5C,OAAIwE,IAAsBA,EAAkB,UAAY7F,MACtDX,EAAkB,oBAAsBA,EAAkB,kBAAoB,KAAKgC,CAAE,EAAIwE,GAE3FxG,EAAkBgC,CAAE,EAAIH,EACxBA,EAAU,KAAOa,GAAsBb,EAAW0E,CAAS,EACpD1E,EAAU,KAAM,CACxB,EACAvB,EAAkB,CAAC,EAAI,IAAM,CAAE,EAC/BA,EAAkB,CAAC,EAAE,SAAW,GAEhCA,EAAkB,EAAI,EAAKmG,GAAS,CAEnC,IAAIzD,EAASyD,EAAK,OACdhF,EAAQ,OAAOgF,EAAK,CAAC,EAAI,IAAOA,EAAK,CAAC,EAAI,IAAQA,EAAK,CAAC,CAAC,EAC7D,QAAS3E,EAAI,EAAGA,EAAIkB,EAAQlB,IAC3BL,IAAU,GACVA,GAAS,OAAOgF,EAAK3E,CAAC,CAAC,EAExB,OAAOL,CACR,EAEA,IAAIiF,GAAS,CAAE,MAAO,UAAW,cAAc,EAC/CpG,EAAkB,GAAI,EAAI,IAAM,CAC/B,IAAImG,EAAOrE,EAAM,EACjB,OAAQsE,GAAOD,EAAK,CAAC,CAAC,GAAK,OAAOA,EAAK,CAAC,CAAC,CAC1C,EAEAnG,EAAkB,GAAI,EAAKmG,GAAS,CAEnC,IAAIzE,EAAKzB,EAAS,UAAUT,EAAW,CAAC,EACnCO,IACJA,EAAe,IAAI,KACpB,IAAImC,EAAQ5C,EAAIE,CAAQ,EACpB6G,EAGAnE,GAAS,KAAQA,EAAQ,KAAQA,GAAS,KAAQA,GAAS,IAC9DmE,EAAS,CAAE,EAEXA,EAAS,CAAE,EAEZ,IAAIC,EAAW,CAAE,OAAAD,CAAQ,EACzBtG,EAAa,IAAI2B,EAAI4E,CAAQ,EAC7B,IAAIC,EAAmBzE,EAAM,EAC7B,OAAIwE,EAAS,KACL,OAAO,OAAOD,EAAQE,CAAgB,GAC9CD,EAAS,OAASC,EACXA,EACR,EAEAvG,EAAkB,GAAI,EAAKmG,GAAS,CAEnC,IAAIzE,EAAKzB,EAAS,UAAUT,EAAW,CAAC,EACpC8G,EAAWvG,EAAa,IAAI2B,CAAE,EAClC,OAAA4E,EAAS,KAAO,GACTA,EAAS,MACjB,EAEAtG,EAAkB,GAAI,EAAI,IAAM,IAAI,IAAI8B,EAAI,CAAE,EAEvC,MAAM0E,GAAc,CAAC,OAAO,QAAQ,eAAe,QAAQ,SAAS,QAAQ,SAAS,UAAU,UAAU,WAAW,WAAW,EAAE,IAAId,GAAQA,EAAO,OAAO,EAElK,IAAIe,GAAO,OAAO,YAAe,SAAW,WAAa,OACzDzG,EAAkB,GAAI,EAAKmG,GAAS,CACnC,IAAIO,EAAWP,EAAK,CAAC,EACjBQ,EAAiBH,GAAYE,CAAQ,EACzC,GAAI,CAACC,EACJ,MAAM,IAAI,MAAM,uCAAyCD,CAAQ,EAElE,OAAO,IAAID,GAAKE,CAAc,EAAE,WAAW,UAAU,MAAM,KAAKR,EAAM,CAAC,EAAE,MAAM,CAChF,EACAnG,EAAkB,GAAI,EAAI,IAAM,CAC/B,IAAImG,EAAOrE,EAAM,EACjB,OAAO,IAAI,OAAOqE,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACnC,EACA,MAAMS,GAAc,CAAE,EACtB5G,EAAkB,EAAI,EAAKmG,GAAS,CACnC,IAAIU,GAAYV,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,GAAKA,EAAK,CAAC,EACtEW,EAAetH,EACnBA,OAAAA,GAAYqH,EAAWV,EAAK,OAC5BrG,EAAiB8G,GACjB9G,EAAiB,CAAC2F,KAAoBA,IAAkB,EACxD3F,EAAe,UAAY,EAC3BA,EAAe,UAAY,EAC3BA,EAAe,mBAAqBN,EACpCA,EAAWsH,EACJhF,EAAM,CACd,EAEA9B,EAAkB,GAAI,EAAKmG,GAEtBA,EAAK,QAAU,EACX,IAAI,MAAMA,EAAK,CAAC,EAAI,UAAaA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,GAAKA,EAAK,CAAC,GAAK,GAAI,EACjFA,EAAK,QAAU,EAChB,IAAI,OACRA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,IAAMA,EAAK,CAAC,GAAK,IAAM,MACtEA,EAAK,CAAC,EAAI,GAAO,WAAcA,EAAK,CAAC,EAAI,UAAaA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,GAAKA,EAAK,CAAC,GAAK,GAAI,EAClGA,EAAK,QAAU,GAChB,IAAI,OACRA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,KAAOA,EAAK,CAAC,GAAK,GAAKA,EAAK,CAAC,GAAK,MAC9DA,EAAK,CAAC,EAAI,IAAQ,iBAAmB,GAAKA,EAAK,CAAC,EAAI,cAAgBA,EAAK,CAAC,EAAI,WAAcA,EAAK,CAAC,EAAI,UAAaA,EAAK,CAAC,GAAK,KAAOA,EAAK,EAAE,GAAK,GAAKA,EAAK,EAAE,GAAK,GAAI,EAEnK,IAAI,KAAK,SAAS,EAK3B,SAASxF,GAAUoG,EAAU,CAG5B,IAAIC,EAAczH,EACd0H,EAAgBzH,EAEhB0H,EAAsBtH,EACtBuH,EAAoBtH,EACpBuH,EAAiBzH,EAEjB0H,EAAoBtH,EACpBuH,EAAsBxH,EAGtByH,EAAW,IAAI,WAAWjI,EAAI,MAAM,EAAGC,CAAM,CAAC,EAC9CiI,EAAkB9H,EAClB+H,EAA0B/H,EAAkB,MAAM,EAAGA,EAAkB,MAAM,EAC7EgI,EAAajI,EACbkI,EAAsBtH,EACtBc,EAAQ4F,EAAU,EACtB,OAAAxH,EAASyH,EACTxH,EAAWyH,EAEXrH,EAAiBsH,EACjBrH,EAAesH,EACfxH,EAAYyH,EAEZrH,EAAesH,EACfvH,EAAiBwH,EACjBhI,EAAMiI,EACNlH,EAAiBsH,EACjBjI,EAAoB8H,EACpB9H,EAAkB,OAAO,EAAGA,EAAkB,OAAQ,GAAG+H,CAAuB,EAChFhI,EAAiBiI,EACjBzH,EAAW,IAAI,SAASX,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC3D6B,CACR,CACO,SAASP,IAAc,CAC7BtB,EAAM,KACNS,EAAe,KACfL,EAAoB,IACrB,CASO,MAAMwD,GAAS,IAAI,MAAM,GAAG,EACnC,QAAS1B,EAAI,EAAGA,EAAI,IAAKA,IACxB0B,GAAO1B,CAAC,EAAI,EAAE,KAAO,KAAK,MAAM,MAAQA,EAAI,MAAO,GAGpD,IAAIJ,GAAiB,IAAIZ,GAAQ,CAAE,WAAY,EAAK,CAAE,EAChCY,GAAe,OACPA,GAAe,eACvBA,GAAe,OAOrC,IAAIwG,GAAW,IAAI,aAAa,CAAC,EACnB,IAAI,WAAWA,GAAS,OAAQ,EAAG,CAAC,EChoClD,IAAIC,GACJ,GAAI,CACHA,GAAc,IAAI,WACnB,MAAgB,CAAE,CAClB,IAAIC,GAAYC,GAChB,MAAMC,GAAgB,OAAO,OAAW,IAClCC,GAAoBD,GACzB,SAAStF,EAAQ,CAAE,OAAO,OAAO,gBAAgBA,CAAM,CAAC,EAAK,WACxDwF,GAAYF,GAAgB,OAAS,WACrCG,GAAkBH,GAAgB,WAAc,WACtD,IAAI3B,EAAQ+B,GACRC,EACA7I,EAAW,EACX8I,EACAxI,EAAiB,KACjByI,GACJ,MAAMC,GAAkB,MAClBC,GAAc,kBACPC,EAAgB,OAAO,WAAW,EACxC,MAAMC,WAAcnI,EAAQ,CAClC,YAAYC,EAAS,CACpB,MAAMA,CAAO,EACb,KAAK,OAAS,EAEd,IAAIgE,EACAmE,EACAC,EACA9I,EACA+I,EAAaZ,GAAU,UAAU,UAAY,SAASvF,EAAQnD,EAAU,CAC3E,OAAO6G,EAAO,UAAU1D,EAAQnD,EAAU,UAAU,CACvD,EAAOqI,IAAeA,GAAY,WAC/B,SAASlF,EAAQnD,EAAU,CAC1B,OAAOqI,GAAY,WAAWlF,EAAQ0D,EAAO,SAAS7G,CAAQ,CAAC,EAAE,OACrE,EAAO,GAEDuJ,EAAQ,KACPtI,IACJA,EAAU,CAAE,GACb,IAAIuI,EAAevI,GAAWA,EAAQ,WAClCwI,EAAsBxI,EAAQ,YAAcA,EAAQ,eACpDyI,EAAsBzI,EAAQ,oBAGlC,GAFIyI,GAAuB,OAC1BA,EAAsBD,EAAsB,GAAK,GAC9CC,EAAsB,KACzB,MAAM,IAAI,MAAM,oCAAoC,EACjDzI,EAAQ,iBAAmBA,EAAQ,WAAa,OACnD,KAAK,UAAY,IAElB,IAAI0I,EAAmB1I,EAAQ,iBAC3B0I,GAAoB,OACvBA,EAAmBF,EAAsB,GAAK,IAC3C,CAAC,KAAK,YAAcxI,EAAQ,YAAc,KAC7C,KAAK,WAAa,CAAE,GAErB,IAAI2I,EAAoBF,EAAsB,IAAOC,EAAmBD,EAAsB,GAC1FG,EAAgBH,EAAsB,GACtCI,EAAiBJ,EAAsBC,EAAmB,GAC9D,GAAIG,EAAiB,KACpB,MAAM,IAAI,MAAM,sDAAsD,EAEvE,IAAIC,EAAoB,CAAE,EACtBC,GAAmB,EACnBC,GAAuC,EAE3C,KAAK,KAAO,KAAK,OAAS,SAAStI,EAAOuI,EAAe,CAwBxD,GAvBKrD,IACJA,EAAS,IAAI4B,GAAkB,IAAI,EACnCI,EAAahC,EAAO,WAAaA,EAAO,SAAW,IAAI,SAASA,EAAO,OAAQ,EAAG,IAAI,GACtF7G,EAAW,GAEZ8I,EAAUjC,EAAO,OAAS,GACtBiC,EAAU9I,EAAW,MAExB6G,EAAS,IAAI4B,GAAkB5B,EAAO,MAAM,EAC5CgC,EAAahC,EAAO,WAAaA,EAAO,SAAW,IAAI,SAASA,EAAO,OAAQ,EAAGA,EAAO,MAAM,GAC/FiC,EAAUjC,EAAO,OAAS,GAC1B7G,EAAW,GAEXA,EAAYA,EAAW,EAAK,WAC7BiF,EAAQjF,EACJkK,EAAgBC,KAAqBnK,GAAakK,EAAgB,KACtE3J,EAAegJ,EAAM,gBAAkB,IAAI,IAAQ,KAC/CA,EAAM,eAAiB,OAAO5H,GAAU,UAC3CrB,EAAiB,CAAE,EACnBA,EAAe,KAAO,KAEtBA,EAAiB,KAClB+I,EAAaE,EAAM,WACfF,EAAY,CACXA,EAAW,gBACdA,EAAaE,EAAM,iBAAiBA,EAAM,cAAa,CAAE,GAC1D,IAAInH,EAAeiH,EAAW,cAAgB,EAC9C,GAAIjH,EAAesH,EAElB,MAAM,IAAI,MAAM,qGAAuGL,EAAW,YAAY,EAE/I,GAAI,CAACA,EAAW,YAAa,CAE5BA,EAAW,YAAc,OAAO,OAAO,IAAI,EAC3C,QAASrH,EAAI,EAAGA,EAAII,EAAcJ,IAAK,CACtC,IAAIoI,EAAOf,EAAWrH,CAAC,EACvB,GAAI,CAACoI,EACJ,SACD,IAAIC,EAAgBC,EAAajB,EAAW,YAC5C,QAASzD,EAAI,EAAG3D,EAAImI,EAAK,OAAQxE,EAAI3D,EAAG2D,IAAK,CAC5C,IAAI9C,EAAMsH,EAAKxE,CAAC,EAChByE,EAAiBC,EAAWxH,CAAG,EAC1BuH,IACJA,EAAiBC,EAAWxH,CAAG,EAAI,OAAO,OAAO,IAAI,GAEtDwH,EAAaD,CACb,CACDC,EAAWpB,CAAa,EAAIlH,EAAI,EAChC,CACD,KAAK,0BAA4BI,CACjC,CACIoH,IACJH,EAAW,OAASjH,EAAe,GAEpC,CACGgH,IACHA,EAAkB,IACnB,IAAImB,EACJ,GAAI,CACChB,EAAM,uBAAyB5H,GAASA,EAAM,aAAeA,EAAM,cAAgB,OACtF6I,GAAY7I,CAAK,EAEjB8I,EAAK9I,CAAK,EACX,IAAI+I,EAAapK,EAGjB,GAFIA,GACHqK,GAAa1F,EAAOwF,EAAM,CAAC,EACxBlK,GAAgBA,EAAa,YAAa,CAC7C,IAAIqK,EAAcrK,EAAa,YAAY,KAAK,CAAC6E,EAAGC,IAAMD,EAAE,OAASC,EAAE,OAAS,EAAI,EAAE,EAClFrD,EAAI4I,EAAY,OAChBC,EAAoB,GACxB,KAAOH,GAAc1I,EAAI,GAAG,CAC3B,IAAI8I,EAAiBF,EAAY,EAAE5I,CAAC,EAAE,OAASiD,EAC3C6F,EAAkBJ,EAAW,gBAAkBzF,GAAU4F,IAAsB,KAClFA,EAAoB,GACjBC,EAAkBJ,EAAW,SAAWzF,EACvC4F,GAAqB,IACxBA,GAAqB,IAElBA,GAAqB,IAExBhC,EAAW,UAAU6B,EAAW,SAAWzF,EAC1C4D,EAAW,UAAU6B,EAAW,SAAWzF,CAAK,EAAI4F,CAAiB,EACtEA,EAAoB,IAErBH,EAAaA,EAAW,SACxB1I,IAED,CACG6I,GAAqB,GAAKH,GAE7B7B,EAAW,UAAU6B,EAAW,SAAWzF,EAC1C4D,EAAW,UAAU6B,EAAW,SAAWzF,CAAK,EAAI4F,CAAiB,EAEvE7K,GAAY4K,EAAY,OAAS,EAC7B5K,EAAW8I,GACdiC,EAAS/K,CAAQ,EAClBuJ,EAAM,OAASvJ,EACf,IAAIgL,EAAaC,GAAUpE,EAAO,SAAS5B,EAAOjF,CAAQ,EAAG4K,CAAW,EACxE,OAAArK,EAAe,KACRyK,CACP,CAED,OADAzB,EAAM,OAASvJ,EACXkK,EAAgBgB,IACnBrE,EAAO,MAAQ5B,EACf4B,EAAO,IAAM7G,EACN6G,GAEDA,EAAO,SAAS5B,EAAOjF,CAAQ,CACtC,OAAOqB,EAAO,CACd,MAAAkJ,EAAgBlJ,EACVA,CACV,QAAa,CACT,GAAIgI,IACH8B,KACI/B,GAAmBG,EAAM,gBAAgB,CAC5C,IAAInH,EAAeiH,EAAW,cAAgB,EAE1C+B,EAAevE,EAAO,SAAS5B,EAAOjF,CAAQ,EAC9CqL,EAAgBC,GAAkBjC,EAAYE,CAAK,EACvD,GAAI,CAACgB,EACJ,OAAIhB,EAAM,eAAe8B,EAAeA,EAAc,YAAY,IAAM,GAEhE9B,EAAM,KAAK5H,EAAOuI,CAAa,GAEvCX,EAAM,0BAA4BnH,EAC3BgJ,EAER,CAEElB,EAAgBqB,KACnBvL,EAAWiF,EACZ,CACD,EACD,MAAMkG,GAAkB,IAAM,CACzBlB,GAAuC,IAC1CA,KACD,IAAI7H,EAAeiH,EAAW,cAAgB,EAG9C,GAFIA,EAAW,OAASjH,GAAgB,CAACoH,IACxCH,EAAW,OAASjH,GACjB4H,GAAmB,IAEtBX,EAAW,YAAc,KACzBY,GAAuC,EACvCD,GAAmB,EACfD,EAAkB,OAAS,IAC9BA,EAAoB,CAAE,WACbA,EAAkB,OAAS,GAAK,CAACP,EAAc,CACzD,QAASxH,EAAI,EAAGC,EAAI8H,EAAkB,OAAQ/H,EAAIC,EAAGD,IACpD+H,EAAkB/H,CAAC,EAAEkH,CAAa,EAAI,EAEvCa,EAAoB,CAAE,CACtB,CACD,EACKyB,GAAa7J,GAAU,CAC5B,IAAIuB,EAASvB,EAAM,OACfuB,EAAS,GACZ2D,EAAO7G,GAAU,EAAI,IAAOkD,EAClBA,EAAS,OACnB2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,EAC/B2D,EAAO7G,GAAU,EAAIkD,EAAS,MAE9B2D,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUkD,CAAM,EACrClD,GAAY,GAEb,QAASgC,EAAI,EAAGA,EAAIkB,EAAQlB,IAC3ByI,EAAK9I,EAAMK,CAAC,CAAC,CAEd,EACKyI,EAAQ9I,GAAU,CACnB3B,EAAW8I,IACdjC,EAASkE,EAAS/K,CAAQ,GAE3B,IAAIkG,EAAO,OAAOvE,EACduB,EACJ,GAAIgD,IAAS,SAAU,CACtB,IAAIuF,EAAY9J,EAAM,OACtB,GAAIrB,GAAkBmL,GAAa,GAAKA,EAAY,KAAQ,CAC3D,IAAKnL,EAAe,MAAQmL,GAAazC,GAAiB,CACzD,IAAI0C,EACAC,GAAYrL,EAAe,CAAC,EAAIA,EAAe,CAAC,EAAE,OAAS,EAAIA,EAAe,CAAC,EAAE,OAAS,GAAK,GAC/FN,EAAW2L,EAAW7C,IACzBjC,EAASkE,EAAS/K,EAAW2L,CAAQ,GACtC,IAAIjB,EACApK,EAAe,UAClBoK,EAAapK,EACbuG,EAAO7G,CAAQ,EAAI,IACnBA,GAAY,EACZ6G,EAAO7G,GAAU,EAAI,GACrB0L,EAAW1L,EAAWiF,EACtBjF,GAAY,EACZ2K,GAAa1F,EAAOwF,EAAM,CAAC,EAC3B5B,EAAW,UAAU6C,EAAWzG,EAAQ,EAAGjF,EAAWiF,EAAQyG,CAAQ,IAEtE7E,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,GACrB0L,EAAW1L,EAAWiF,EACtBjF,GAAY,GAEbM,EAAiB,CAAC,GAAI,EAAE,EACxBA,EAAe,SAAWoK,EAC1BpK,EAAe,KAAO,EACtBA,EAAe,SAAWoL,CAC1B,CACD,IAAIE,EAAU3C,GAAY,KAAKtH,CAAK,EACpCrB,EAAesL,EAAU,EAAI,CAAC,GAAKjK,EACnCkF,EAAO7G,GAAU,EAAI,IACrByK,EAAKmB,EAAU,CAACH,EAAYA,CAAS,EACrC,MACA,CACD,IAAII,EAEAJ,EAAY,GACfI,EAAa,EACHJ,EAAY,IACtBI,EAAa,EACHJ,EAAY,MACtBI,EAAa,EAEbA,EAAa,EAEd,IAAIF,EAAWF,EAAY,EAI3B,GAHIzL,EAAW2L,EAAW7C,IACzBjC,EAASkE,EAAS/K,EAAW2L,CAAQ,GAElCF,EAAY,IAAQ,CAACnC,EAAY,CACpC,IAAItH,EAAG8J,EAAIC,EAAIC,EAAchM,EAAW6L,EACxC,IAAK7J,EAAI,EAAGA,EAAIyJ,EAAWzJ,IAC1B8J,EAAKnK,EAAM,WAAWK,CAAC,EACnB8J,EAAK,IACRjF,EAAOmF,GAAa,EAAIF,EACdA,EAAK,MACfjF,EAAOmF,GAAa,EAAIF,GAAM,EAAI,IAClCjF,EAAOmF,GAAa,EAAIF,EAAK,GAAO,MAEnCA,EAAK,SAAY,SAChBC,EAAKpK,EAAM,WAAWK,EAAI,CAAC,GAAK,SAAY,OAE9C8J,EAAK,QAAYA,EAAK,OAAW,KAAOC,EAAK,MAC7C/J,IACA6E,EAAOmF,GAAa,EAAIF,GAAM,GAAK,IACnCjF,EAAOmF,GAAa,EAAIF,GAAM,GAAK,GAAO,IAC1CjF,EAAOmF,GAAa,EAAIF,GAAM,EAAI,GAAO,IACzCjF,EAAOmF,GAAa,EAAIF,EAAK,GAAO,MAEpCjF,EAAOmF,GAAa,EAAIF,GAAM,GAAK,IACnCjF,EAAOmF,GAAa,EAAIF,GAAM,EAAI,GAAO,IACzCjF,EAAOmF,GAAa,EAAIF,EAAK,GAAO,KAGtC5I,EAAS8I,EAAchM,EAAW6L,CACvC,MACK3I,EAASoG,EAAW3H,EAAO3B,EAAW6L,CAAU,EAG7C3I,EAAS,GACZ2D,EAAO7G,GAAU,EAAI,IAAOkD,EAClBA,EAAS,KACf2I,EAAa,GAChBhF,EAAO,WAAW7G,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAIkD,CAAM,EAEpE2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GACXA,EAAS,OACf2I,EAAa,GAChBhF,EAAO,WAAW7G,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAIkD,CAAM,EAEpE2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,EAC/B2D,EAAO7G,GAAU,EAAIkD,EAAS,MAE1B2I,EAAa,GAChBhF,EAAO,WAAW7G,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAIkD,CAAM,EAEpE2D,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUkD,CAAM,EACrClD,GAAY,GAEbA,GAAYkD,CAChB,SAAcgD,IAAS,SACnB,GAAIvE,IAAU,IAAMA,EAEfA,EAAQ,IAASA,EAAQ,KAAQ,KAAK,aAAe,IAAWA,EAAQ,IAAQ,CAAC,KAAK,sBACzFkF,EAAO7G,GAAU,EAAI2B,EACXA,EAAQ,KAClBkF,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI2B,GACXA,EAAQ,OAClBkF,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI2B,GAAS,EAC9BkF,EAAO7G,GAAU,EAAI2B,EAAQ,MAE7BkF,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAU2B,CAAK,EACpC3B,GAAY,WAEH2B,GAAS,IAAMA,EACrBA,GAAS,IACZkF,EAAO7G,GAAU,EAAI,IAAQ2B,EACnBA,GAAS,MACnBkF,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI2B,EAAQ,KACnBA,GAAS,QACnBkF,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,SAAS7I,EAAU2B,CAAK,EACnC3B,GAAY,IAEZ6G,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,SAAS7I,EAAU2B,CAAK,EACnC3B,GAAY,OAEP,CACN,IAAIiM,EACJ,IAAKA,EAAa,KAAK,YAAc,GAAKtK,EAAQ,YAAeA,GAAS,YAAa,CACtFkF,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,WAAW7I,EAAU2B,CAAK,EACrC,IAAIuK,EACJ,GAAID,EAAa,IAEbC,EAAWvK,EAAQ+B,IAASmD,EAAO7G,CAAQ,EAAI,MAAS,EAAM6G,EAAO7G,EAAW,CAAC,GAAK,CAAE,IAAM,IAAOkM,EAAU,CAClHlM,GAAY,EACZ,MACA,MACAA,GACD,CACD6G,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,WAAW7I,EAAU2B,CAAK,EACrC3B,GAAY,CACZ,SACSkG,IAAS,UAAYA,IAAS,WACxC,GAAI,CAACvE,EACJkF,EAAO7G,GAAU,EAAI,QACjB,CACJ,GAAIO,EAAc,CACjB,IAAI4L,EAAU5L,EAAa,IAAIoB,CAAK,EACpC,GAAIwK,EAAS,CACZ,GAAI,CAACA,EAAQ,GAAI,CAChB,IAAIvB,EAAcrK,EAAa,cAAgBA,EAAa,YAAc,CAAA,GAC1E4L,EAAQ,GAAKvB,EAAY,KAAKuB,CAAO,CACrC,CACDtF,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUmM,EAAQ,EAAE,EACzCnM,GAAY,EACZ,MACA,MACAO,EAAa,IAAIoB,EAAO,CAAE,OAAQ3B,EAAWiF,EAAO,CACrD,CACD,IAAImH,EAAczK,EAAM,YACxB,GAAIyK,IAAgB,OACnBC,GAAY1K,EAAO,EAAI,UACbyK,IAAgB,MAC1BZ,GAAU7J,CAAK,UACLyK,IAAgB,IAC1B,GAAI,KAAK,iBAAkBvF,EAAO7G,GAAU,EAAI,QAC3C,CACJkD,EAASvB,EAAM,KACXuB,EAAS,GACZ2D,EAAO7G,GAAU,EAAI,IAAOkD,EAClBA,EAAS,OACnB2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,EAC/B2D,EAAO7G,GAAU,EAAIkD,EAAS,MAE9B2D,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUkD,CAAM,EACrClD,GAAY,GAEb,OAAS,CAAC8C,EAAKwJ,CAAU,IAAK3K,EAC7B8I,EAAK3H,CAAG,EACR2H,EAAK6B,CAAU,CAEhB,KACK,CACN,QAAStK,EAAI,EAAGC,EAAIqG,GAAW,OAAQtG,EAAIC,EAAGD,IAAK,CAClD,IAAIuK,EAAiBhE,GAAiBvG,CAAC,EACvC,GAAIL,aAAiB4K,EAAgB,CACpC,IAAI3I,EAAY0E,GAAWtG,CAAC,EAC5B,GAAI4B,EAAU,MAAO,CAChBA,EAAU,OACbiD,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI4D,EAAU,KAC/BiD,EAAO7G,GAAU,EAAI,GAEtB,IAAIwM,EAAc5I,EAAU,MAAM,KAAK,KAAMjC,CAAK,EAC9C6K,IAAgB7K,EACf,MAAM,QAAQA,CAAK,EACtB6J,GAAU7J,CAAK,EAEf0K,GAAY1K,CAAK,EAGlB8I,EAAK+B,CAAW,EAEjB,MACA,CACD,IAAIC,EAAgB5F,EAChB6F,EAAoB7D,EACpB8D,EAAkB3M,EACtB6G,EAAS,KACT,IAAIxE,EACJ,GAAI,CACHA,EAASuB,EAAU,KAAK,KAAK,KAAMjC,EAAQD,IAE1CmF,EAAS4F,EACTA,EAAgB,KAChBzM,GAAY0B,EACR1B,EAAW8I,GACdiC,EAAS/K,CAAQ,EACX,CACN,OAAA6G,EAAQ,WAAAgC,EAAY,SAAU7I,EAAW0B,CACzC,GACC+I,CAAI,CAChB,QAAkB,CAELgC,IACH5F,EAAS4F,EACT5D,EAAa6D,EACb1M,EAAW2M,EACX7D,EAAUjC,EAAO,OAAS,GAE3B,CACGxE,IACCA,EAAO,OAASrC,EAAW8I,GAC9BiC,EAAS1I,EAAO,OAASrC,CAAQ,EAClCA,EAAW4M,GAAmBvK,EAAQwE,EAAQ7G,EAAU4D,EAAU,IAAI,GAEvE,MACA,CACD,CAED,GAAI,MAAM,QAAQjC,CAAK,EACtB6J,GAAU7J,CAAK,MACT,CAEN,GAAIA,EAAM,OAAQ,CACjB,MAAMkL,EAAOlL,EAAM,OAAQ,EAE3B,GAAIkL,IAASlL,EACZ,OAAO8I,EAAKoC,CAAI,CACjB,CAGD,GAAI3G,IAAS,WACZ,OAAOuE,EAAK,KAAK,eAAiB,KAAK,cAAc9I,CAAK,CAAC,EAG5D0K,GAAY1K,EAAO,CAACA,EAAM,cAAc,CACxC,CACD,CACD,SACSuE,IAAS,UACnBW,EAAO7G,GAAU,EAAI2B,EAAQ,IAAO,YAC1BuE,IAAS,SAAU,CAC7B,GAAIvE,EAAS,OAAO,CAAC,GAAG,OAAO,EAAE,GAAMA,GAAS,EAAE,OAAO,CAAC,GAAG,OAAO,EAAE,GAErEkF,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,YAAY7I,EAAU2B,CAAK,UAC5BA,EAAS,OAAO,CAAC,GAAG,OAAO,EAAE,GAAMA,EAAQ,EAErDkF,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,aAAa7I,EAAU2B,CAAK,UAGnC,KAAK,mBACRkF,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,WAAW7I,EAAU,OAAO2B,CAAK,CAAC,UACnC,KAAK,oBAAsBA,EAAQ,IAAK,OAAUA,EAAQ,EAAE,IAAK,OAAS,CACpFkF,EAAO7G,GAAU,EAAI,IACrBA,IACA6G,EAAO7G,GAAU,EAAI,GACrB,IAAIkF,EAAQ,CAAA,EACR4H,EACJ,EAAG,CACF,IAAI3H,EAAOxD,EAAQ,MACnBmL,GAAe3H,EAAO,UAAYxD,EAAQ,GAAK,MAAQ,IACvDuD,EAAM,KAAKC,CAAI,EACfxD,IAAU,EACjB,OAAe,GAAGA,IAAU,IAAMA,IAAU,CAAC,KAAOmL,IAC9CjG,EAAO7G,EAAS,CAAC,EAAIkF,EAAM,OAC3B,QAASlD,EAAIkD,EAAM,OAAQlD,EAAI,GAC9B6E,EAAO7G,GAAU,EAAI,OAAOkF,EAAM,EAAElD,CAAC,CAAC,EAEvC,MACN,KACM,OAAM,IAAI,WAAWL,EAAQ,qIAC0C,EAGzE3B,GAAY,CAChB,SAAckG,IAAS,YACf,KAAK,qBACRW,EAAO7G,GAAU,EAAI,KAErB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,EACrB6G,EAAO7G,GAAU,EAAI,OAGtB,OAAM,IAAI,MAAM,iBAAmBkG,CAAI,CAExC,EAEK6G,GAAoB,KAAK,iBAAmB,KAAK,qBAAyBlK,GAAW,CAE1F,IAAIuH,EAAO,OAAO,KAAKvH,CAAM,EACzBK,EAASkH,EAAK,OACdlH,EAAS,GACZ2D,EAAO7G,GAAU,EAAI,IAAOkD,EAClBA,EAAS,OACnB2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,EAC/B2D,EAAO7G,GAAU,EAAIkD,EAAS,MAE9B2D,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUkD,CAAM,EACrClD,GAAY,GAEb,IAAI8C,EACJ,GAAI,KAAK,qBACR,QAASd,EAAI,EAAGA,EAAIkB,EAAQlB,IAAK,CAChCc,EAAMsH,EAAKpI,CAAC,EACZ,IAAIgL,EAAM,OAAOlK,CAAG,EACpB2H,EAAK,MAAMuC,CAAG,EAAIlK,EAAMkK,CAAG,EAC3BvC,EAAK5H,EAAOC,CAAG,CAAC,CAChB,KAGD,SAASd,EAAI,EAAGA,EAAIkB,EAAQlB,IAC3ByI,EAAK3H,EAAMsH,EAAKpI,CAAC,CAAC,EAClByI,EAAK5H,EAAOC,CAAG,CAAC,CAGlB,EACD,CAACD,EAAQoK,IAAkB,CAC1BpG,EAAO7G,GAAU,EAAI,IACrB,IAAIkN,EAAelN,EAAWiF,EAC9BjF,GAAY,EACZ,IAAI0B,EAAO,EACX,QAASoB,KAAOD,GACXoK,GAAiBpK,EAAO,eAAeC,CAAG,KAC7C2H,EAAK3H,CAAG,EACR2H,EAAK5H,EAAOC,CAAG,CAAC,EAChBpB,KAGFmF,EAAOqG,IAAiBjI,CAAK,EAAIvD,GAAQ,EACzCmF,EAAOqG,EAAejI,CAAK,EAAIvD,EAAO,GACtC,EAEKyL,GAAc,KAAK,aAAe,GAAQJ,GAC/C9L,EAAQ,oBAAsB,CAAC2I,EAChC,CAAC/G,EAAQoK,IAAkB,CAC1B,IAAI5C,EAAgBC,EAAajB,EAAW,cAAgBA,EAAW,YAAc,OAAO,OAAO,IAAI,GACnG6D,EAAelN,IAAaiF,EAC5BmI,EACJ,QAAStK,KAAOD,EACf,GAAIoK,GAAiBpK,EAAO,eAAeC,CAAG,EAAG,CAEhD,GADAuH,EAAiBC,EAAWxH,CAAG,EAC3BuH,EACHC,EAAaD,MACT,CAEJ,IAAID,EAAO,OAAO,KAAKvH,CAAM,EACzBwK,EAAiB/C,EACrBA,EAAajB,EAAW,YACxB,IAAIiE,EAAiB,EACrB,QAAStL,EAAI,EAAGC,EAAImI,EAAK,OAAQpI,EAAIC,EAAGD,IAAK,CAC5C,IAAIc,EAAMsH,EAAKpI,CAAC,EAChBqI,EAAiBC,EAAWxH,CAAG,EAC1BuH,IACJA,EAAiBC,EAAWxH,CAAG,EAAI,OAAO,OAAO,IAAI,EACrDwK,KAEDhD,EAAaD,CACb,CACG6C,EAAejI,EAAQ,GAAKjF,GAE/BA,IACAuN,GAAUjD,EAAYF,EAAMkD,CAAc,GAE1CE,GAAgBlD,EAAYF,EAAM8C,EAAcI,CAAc,EAC/DF,EAAY,GACZ9C,EAAa+C,EAAevK,CAAG,CAC/B,CACD2H,EAAK5H,EAAOC,CAAG,CAAC,CAChB,CAEF,GAAI,CAACsK,EAAW,CACf,IAAIK,EAAWnD,EAAWpB,CAAa,EACnCuE,EACH5G,EAAOqG,EAAejI,CAAK,EAAIwI,EAE/BD,GAAgBlD,EAAY,OAAO,KAAKzH,CAAM,EAAGqK,EAAc,CAAC,CACjE,CACD,EACD,CAACrK,EAAQoK,IAAkB,CAC1B,IAAI5C,EAAgBC,EAAajB,EAAW,cAAgBA,EAAW,YAAc,OAAO,OAAO,IAAI,GACnGiE,EAAiB,EACrB,QAASxK,KAAOD,GAAYoK,GAAiBpK,EAAO,eAAeC,CAAG,KACrEuH,EAAiBC,EAAWxH,CAAG,EAC1BuH,IACJA,EAAiBC,EAAWxH,CAAG,EAAI,OAAO,OAAO,IAAI,EACrDwK,KAEDhD,EAAaD,GAEd,IAAIoD,EAAWnD,EAAWpB,CAAa,EACnCuE,EACCA,GAAY,IAAQ7D,GACvB/C,EAAO7G,GAAU,IAAMyN,GAAY,IAAQ,IAAQ,GACnD5G,EAAO7G,GAAU,EAAIyN,GAAY,GAEjC5G,EAAO7G,GAAU,EAAIyN,EAEtBF,GAAUjD,EAAYA,EAAW,UAAY,OAAO,KAAKzH,CAAM,EAAGyK,CAAc,EAGjF,QAASxK,KAAOD,GACXoK,GAAiBpK,EAAO,eAAeC,CAAG,IAC7C2H,EAAK5H,EAAOC,CAAG,CAAC,CAElB,EAGK4K,GAAkB,OAAO,KAAK,YAAc,YAAc,KAAK,WAE/DrB,GAAcqB,GAAkB,CAAC7K,EAAQoK,IAAkB,CAChES,GAAgB7K,CAAM,EAAIsK,GAAYtK,EAAOoK,CAAa,EAAIF,GAAiBlK,EAAOoK,CAAa,CACtG,EAAME,GAEEpC,EAAYtG,GAAQ,CACzB,IAAIkJ,EACJ,GAAIlJ,EAAM,SAAW,CAEpB,GAAKA,EAAMQ,EAAS0D,GACnB,MAAM,IAAI,MAAM,wDAAwD,EACzEgF,EAAU,KAAK,IAAIhF,GAClB,KAAK,MAAM,KAAK,KAAKlE,EAAMQ,IAAUR,EAAM,SAAY,KAAO,GAAI,OAAQ,EAAI,IAAM,EAAI,IAAM,CAC/F,MACAkJ,GAAY,KAAK,IAAKlJ,EAAMQ,GAAU,EAAG4B,EAAO,OAAS,CAAC,GAAK,IAAM,GAAM,GAC5E,IAAI+G,EAAY,IAAInF,GAAkBkF,CAAO,EAC7C,OAAA9E,EAAa+E,EAAU,WAAaA,EAAU,SAAW,IAAI,SAASA,EAAU,OAAQ,EAAGD,CAAO,GAClGlJ,EAAM,KAAK,IAAIA,EAAKoC,EAAO,MAAM,EAC7BA,EAAO,KACVA,EAAO,KAAK+G,EAAW,EAAG3I,EAAOR,CAAG,EAEpCmJ,EAAU,IAAI/G,EAAO,MAAM5B,EAAOR,CAAG,CAAC,EACvCzE,GAAYiF,EACZA,EAAQ,EACR6D,EAAU8E,EAAU,OAAS,GACtB/G,EAAS+G,CAChB,EACKL,GAAY,CAACjD,EAAYF,EAAMkD,IAAmB,CACvD,IAAIG,EAAWpE,EAAW,OACrBoE,IACJA,EAAW,IACRA,EAAW5D,GAAiB,KAAK,sBAAwB,CAAC,KAAK,qBAAqBO,CAAI,GAC3FqD,EAAWpE,EAAW,UAChBoE,EAAW3D,IAChB2D,EAAW5D,GACZR,EAAW,UAAYoE,EAAW,IAE9BA,GAAY3D,IACf2D,EAAW5D,GACZR,EAAW,OAASoE,EAAW,GAEhC,IAAIlJ,EAAW6F,EAAK,SAAWqD,GAAY,IAAQ7D,EAAqB6D,EAAW,IAAS,EAAI,GAChGnD,EAAWpB,CAAa,EAAIuE,EAC5BnD,EAAW,SAAWF,EACtBf,EAAWoE,EAAW,EAAI,EAAIrD,EAE1BqD,EAAW5D,GACdO,EAAK,SAAW,GAChBf,EAAW,aAAeoE,EAAW,GACrCrE,EAAkB,GACd7E,GAAY,GACfsC,EAAO7G,GAAU,GAAKyN,EAAW,IAAQ,GACzC5G,EAAO7G,GAAU,EAAIuE,GAErBsC,EAAO7G,GAAU,EAAIyN,IAGlBlJ,GAAY,GACfsC,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,GAAKyN,EAAW,IAAQ,GACzC5G,EAAO7G,GAAU,EAAIuE,IAErBsC,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIyN,GAGlBH,IACHtD,IAAoBC,GAAuCqD,GAExDvD,EAAkB,QAAUJ,IAC/BI,EAAkB,MAAK,EAAGb,CAAa,EAAI,GAC5Ca,EAAkB,KAAKO,CAAU,EACjCG,EAAKL,CAAI,EAEV,EACKoD,GAAkB,CAAClD,EAAYF,EAAMyD,EAAiBP,IAAmB,CAC9E,IAAIQ,EAAajH,EACbkH,EAAe/N,EACfgO,EAAclF,EACdmF,EAAYhJ,EAChB4B,EAAS+B,GACT5I,EAAW,EACXiF,EAAQ,EACH4B,IACJ+B,GAAa/B,EAAS,IAAI4B,GAAkB,IAAI,GACjDK,EAAUjC,EAAO,OAAS,GAC1B0G,GAAUjD,EAAYF,EAAMkD,CAAc,EAC1C1E,GAAa/B,EACb,IAAIqH,EAAelO,EAKnB,GAJA6G,EAASiH,EACT9N,EAAW+N,EACXjF,EAAUkF,EACV/I,EAAQgJ,EACJC,EAAe,EAAG,CACrB,IAAIC,EAASnO,EAAWkO,EAAe,EACnCC,EAASrF,GACZiC,EAASoD,CAAM,EAChB,IAAIC,EAAoBP,EAAkB5I,EAC1C4B,EAAO,WAAWuH,EAAoBF,EAAcE,EAAoB,EAAGpO,CAAQ,EACnF6G,EAAO,IAAI+B,GAAW,MAAM,EAAGsF,CAAY,EAAGE,CAAiB,EAC/DpO,EAAWmO,CACf,MACItH,EAAOgH,EAAkB5I,CAAK,EAAI2D,GAAW,CAAC,CAE/C,EACK4B,GAAc,CAAC3H,EAAQoK,IAAkB,CAC9C,IAAIoB,EAActF,GAAiBlG,EAAQgE,EAAQ5B,EAAOjF,EAAUqJ,EAAY0B,EAAU,CAACpJ,EAAO0M,EAAaC,IAAuB,CACrI,GAAIA,EACH,OAAOlF,EAAkB,GAC1BpJ,EAAWqO,EACX,IAAIE,EAAc1H,EAGlB,OAFA4D,EAAK9I,CAAK,EACVwJ,KACIoD,IAAgB1H,EACZ,CAAE,SAAA7G,EAAU,WAAA6I,EAAY,OAAAhC,GAEzB7G,CACP,EAAE,IAAI,EACP,GAAIqO,IAAgB,EACnB,OAAOhC,GAAYxJ,EAAQ,EAAI,EAChC7C,EAAWqO,CACX,CACD,CACD,UAAUG,EAAQ,CAEjB3H,EAAS2H,EACT3F,EAAa,IAAI,SAAShC,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAC7E7G,EAAW,CACX,CACD,iBAAkB,CACb,KAAK,aACR,KAAK,WAAa,CAAE,GACjB,KAAK,eACR,KAAK,aAAe,CAAE,EACvB,CACF,CAQAuI,GAAmB,CAAE,KAAM,IAAK,MAAO,OAAQ,YAAa,OAAO,eAAe,WAAW,SAAS,EAAE,YAA4B5H,EAAQ,EAC5I2H,GAAa,CAAC,CACb,KAAKmG,EAAMC,EAAkBjE,EAAM,CAClC,IAAIkE,EAAUF,EAAK,QAAO,EAAK,IAC/B,IAAK,KAAK,gBAAkBA,EAAK,gBAAe,IAAO,IAAME,GAAW,GAAKA,EAAU,WAAa,CAEnG,GAAI,CAAE,OAAA9H,EAAQ,WAAAgC,EAAY,SAAA7I,CAAQ,EAAI0O,EAAiB,CAAC,EACxD7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAU2O,CAAO,CACtC,SAAUA,EAAU,GAAKA,EAAU,WAAa,CAEhD,GAAI,CAAE,OAAA9H,EAAQ,WAAAgC,EAAY,SAAA7I,CAAQ,EAAI0O,EAAiB,EAAE,EACzD7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUyO,EAAK,gBAAiB,EAAG,KAAYE,EAAU,IAAO,YAAgB,EAAE,EACvG9F,EAAW,UAAU7I,EAAW,EAAG2O,CAAO,CAC7C,SAAa,MAAMA,CAAO,EAAG,CAC1B,GAAI,KAAK,cACR,OAAAD,EAAiB,CAAC,EACXjE,EAAK,KAAK,eAAe,EAGjC,GAAI,CAAE,OAAA5D,EAAQ,WAAAgC,EAAY,SAAA7I,CAAQ,EAAI0O,EAAiB,CAAC,EACxD7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,GACxB,KAAS,CAEN,GAAI,CAAE,OAAA6G,EAAQ,WAAAgC,EAAY,SAAA7I,CAAQ,EAAI0O,EAAiB,EAAE,EACzD7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,GACrB6G,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUyO,EAAK,gBAAe,EAAK,GAAO,EAC/D5F,EAAW,YAAY7I,EAAW,EAAG,OAAO,KAAK,MAAM2O,CAAO,CAAC,CAAC,CAChE,CACD,CACF,EAAG,CACF,KAAKC,EAAKF,EAAkBjE,EAAM,CACjC,GAAI,KAAK,iBACR,OAAAiE,EAAiB,CAAC,EACXjE,EAAK,CAAA,CAAE,EAEf,IAAIxH,EAAQ,MAAM,KAAK2L,CAAG,EACtB,CAAE,OAAA/H,EAAQ,SAAA7G,CAAQ,EAAI0O,EAAiB,KAAK,UAAY,EAAI,CAAC,EAC7D,KAAK,YACR7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,GAEtByK,EAAKxH,CAAK,CACV,CACF,EAAG,CACF,KAAK5B,EAAOqN,EAAkBjE,EAAM,CACnC,GAAI,CAAE,OAAA5D,EAAQ,SAAA7G,CAAQ,EAAI0O,EAAiB,KAAK,UAAY,EAAI,CAAC,EAC7D,KAAK,YACR7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,GAEtByK,EAAK,CAAEpJ,EAAM,KAAMA,EAAM,OAAO,CAAE,CAClC,CACF,EAAG,CACF,KAAKwN,EAAOH,EAAkBjE,EAAM,CACnC,GAAI,CAAE,OAAA5D,EAAQ,SAAA7G,CAAQ,EAAI0O,EAAiB,KAAK,UAAY,EAAI,CAAC,EAC7D,KAAK,YACR7H,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAI,GAEtByK,EAAK,CAAEoE,EAAM,OAAQA,EAAM,KAAK,CAAE,CAClC,CACF,EAAG,CACF,KAAKC,EAAaJ,EAAkB,CAC/B,KAAK,UACRK,GAAeD,EAAa,GAAMJ,CAAgB,EAElDM,GAAYxG,GAAgB,OAAO,KAAKsG,CAAW,EAAI,IAAI,WAAWA,CAAW,EAAGJ,CAAgB,CACrG,CACF,EAAG,CACF,KAAKO,EAAYP,EAAkB,CAClC,IAAItC,EAAc6C,EAAW,YACzB7C,IAAgB1D,IAAa,KAAK,UACrCqG,GAAeE,EAAYjI,GAAY,QAAQoF,EAAY,IAAI,EAAGsC,CAAgB,EAElFM,GAAYC,EAAYP,CAAgB,CACzC,CACF,EAAG,CACF,KAAK5C,EAAI4C,EAAkB,CAC1B,GAAI,CAAE,OAAA7H,EAAQ,SAAA7G,CAAQ,EAAI0O,EAAiB,CAAC,EAC5C7H,EAAO7G,CAAQ,EAAI,GACnB,CACF,CAAC,EAED,SAAS+O,GAAeE,EAAY/I,EAAMwI,EAAkBQ,EAAQ,CACnE,IAAIhM,EAAS+L,EAAW,WACxB,GAAI/L,EAAS,EAAI,IAAO,CACvB,GAAI,CAAE,OAAA2D,EAAQ,SAAA7G,CAAQ,EAAK0O,EAAiB,EAAIxL,CAAM,EACtD2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,EAAS,CAChC,SAAYA,EAAS,EAAI,MAAS,CAChC,GAAI,CAAE,OAAA2D,EAAQ,SAAA7G,CAAQ,EAAK0O,EAAiB,EAAIxL,CAAM,EACtD2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAKkD,EAAS,GAAM,EACrC2D,EAAO7G,GAAU,EAAKkD,EAAS,EAAK,GACtC,KAAQ,CACN,GAAI,CAAE,OAAA2D,EAAQ,SAAA7G,EAAU,WAAA6I,CAAY,EAAG6F,EAAiB,EAAIxL,CAAM,EAClE2D,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUkD,EAAS,CAAC,EACzClD,GAAY,CACZ,CACD6G,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkG,EACrBW,EAAO,IAAI,IAAI,WAAWoI,EAAW,OAAQA,EAAW,WAAYA,EAAW,UAAU,EAAGjP,CAAQ,CACrG,CACA,SAASgP,GAAYR,EAAQE,EAAkB,CAC9C,IAAIxL,EAASsL,EAAO,WACpB,IAAI3H,EAAQ7G,EACZ,GAAIkD,EAAS,IAAO,CACnB,GAAI,CAAE,OAAA2D,EAAQ,SAAA7G,CAAQ,EAAK0O,EAAiBxL,EAAS,CAAC,EACtD2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,CACvB,SAAYA,EAAS,MAAS,CAC5B,GAAI,CAAE,OAAA2D,EAAQ,SAAA7G,CAAQ,EAAK0O,EAAiBxL,EAAS,CAAC,EACtD2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,EAC/B2D,EAAO7G,GAAU,EAAIkD,EAAS,GAChC,KAAQ,CACN,GAAI,CAAE,OAAA2D,EAAQ,SAAA7G,EAAU,WAAA6I,CAAY,EAAG6F,EAAiBxL,EAAS,CAAC,EAClE2D,EAAO7G,GAAU,EAAI,IACrB6I,EAAW,UAAU7I,EAAUkD,CAAM,EACrClD,GAAY,CACZ,CACD6G,EAAO,IAAI2H,EAAQxO,CAAQ,CAC5B,CAEA,SAAS4M,GAAmBvK,EAAQwE,EAAQ7G,EAAUkG,EAAM,CAC3D,IAAIhD,EAASb,EAAO,OACpB,OAAQa,EAAM,CACb,IAAK,GACJ2D,EAAO7G,GAAU,EAAI,IACrB,MACD,IAAK,GACJ6G,EAAO7G,GAAU,EAAI,IACrB,MACD,IAAK,GACJ6G,EAAO7G,GAAU,EAAI,IACrB,MACD,IAAK,GACJ6G,EAAO7G,GAAU,EAAI,IACrB,MACD,IAAK,IACJ6G,EAAO7G,GAAU,EAAI,IACrB,MACD,QACKkD,EAAS,KACZ2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GACXA,EAAS,OACnB2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,EAC/B2D,EAAO7G,GAAU,EAAIkD,EAAS,MAE9B2D,EAAO7G,GAAU,EAAI,IACrB6G,EAAO7G,GAAU,EAAIkD,GAAU,GAC/B2D,EAAO7G,GAAU,EAAKkD,GAAU,GAAM,IACtC2D,EAAO7G,GAAU,EAAKkD,GAAU,EAAK,IACrC2D,EAAO7G,GAAU,EAAIkD,EAAS,IAEhC,CACD,OAAA2D,EAAO7G,GAAU,EAAIkG,EACrBW,EAAO,IAAIxE,EAAQrC,CAAQ,EAC3BA,GAAYkD,EACLlD,CACR,CAEA,SAASiL,GAAUD,EAAYJ,EAAa,CAE3C,IAAIuE,EACAC,EAAiBxE,EAAY,OAAS,EACtCyE,EAAUrE,EAAW,OAASoE,EAClC,KAAOD,EAASvE,EAAY,OAAO,CAClC,IAAI0E,EAASH,EAAO,OAChBjN,EAAKiN,EAAO,GAChBnE,EAAW,WAAWsE,EAASF,EAAgBE,EAAQD,CAAO,EAC9DD,GAAkB,EAClB,IAAIpP,EAAWsP,EAASF,EACxBpE,EAAWhL,GAAU,EAAI,IACzBgL,EAAWhL,GAAU,EAAI,IACzBgL,EAAWhL,GAAU,EAAIkC,GAAM,GAC/B8I,EAAWhL,GAAU,EAAKkC,GAAM,GAAM,IACtC8I,EAAWhL,GAAU,EAAKkC,GAAM,EAAK,IACrC8I,EAAWhL,GAAU,EAAIkC,EAAK,IAC9BmN,EAAUC,CACV,CACD,OAAOtE,CACR,CAEA,SAASL,GAAa1F,EAAOwF,EAAMI,EAAmB,CACrD,GAAIvK,EAAe,OAAS,EAAG,CAC9BuI,EAAW,UAAUvI,EAAe,SAAW2E,EAAOjF,EAAW6K,EAAoBvK,EAAe,SAAW2E,CAAK,EACpH3E,EAAe,gBAAkBN,EAAWiF,EAC5C,IAAIsK,EAAejP,EACnBA,EAAiB,KACjBmK,EAAK8E,EAAa,CAAC,CAAC,EACpB9E,EAAK8E,EAAa,CAAC,CAAC,CACpB,CACF,CAaA,SAASjE,GAAkBjC,EAAYE,EAAO,CAC7C,OAAAF,EAAW,aAAgBvH,GAAuB,CACjD,IAAI0N,EAAa,CAAC1N,IAAwByH,EAAM,2BAA6B,KAAOzH,EAAmB,OACvG,OAAK0N,GACJjG,EAAM,iBAAiBzH,CAAkB,EACnC0N,CACP,EACMnG,CACR,CAMA,IAAIoG,GAAe,IAAItG,GAAM,CAAE,WAAY,EAAK,CAAE,EAC9BsG,GAAa,KACXA,GAAa,KAC5B,MAAMC,GAAUvG,GAIV+B,GAAoB,IACpBK,GAAoB,KACpBpB,GAAsB,KC/iCnC,eAAsBwF,IAAO,CAuCzB,MAAMC,GAAoB,KAAe,CAAE,EAAG,IAAM,EAAG,GAAM,EAAG,CAAE,EAAG,CAAE,EAAG,CAAE,EAAG,GAAO,CAAA,CAAK,EAAA,EAAG,IAAI,WAAW,CAAC,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,IAAK,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,IAAK,GAAI,EAAE,CAAC,GAAK,CAEzT,CAEO,MAAMC,WAA4DC,EAAW,CAChF,OACA,OACA,KACA,YAEA,YAAYnJ,EAASuI,EAA4Ba,EAA6B,CACpE,QACN,KAAK,OAASb,EACd,KAAK,OAASa,EACd,KAAK,KAAOpJ,EACP,KAAA,YAAcuI,EAAOvI,CAAI,CAClC,CAEA,MAAM,UAAW,CACN,OAAA,KAAK,OAAO,KAAK,IAAI,CAChC,CAEA,MAAM,UAAW,CACN,OAAA,KAAK,OAAO,KAAK,WAAW,CACvC,CACJ,CAEa,MAAAiJ,GAAsB,MAAUI,GAAuB,CAC5D,IAAAC,EAAc,IAAIC,EAClBC,EAAiB,IAAIC,GACQ,IAAIF,EAAa,CAAE,gBAAiB,GAAM,EACvC,IAAIE,GAAiB,CAAE,gBAAiB,GAAM,EAC3C,IAAIF,EAAa,CAAE,gBAAiB,GAAM,WAAY,EAAA,CAAM,EACzD,IAAIE,GAAiB,CAAE,gBAAiB,GAAM,WAAY,EAAA,CAAM,EAC/D,IAAIF,EAAa,CAAE,gBAAiB,GAAM,WAAY,CAAC,CAAA,CAAG,EACpD,IAAIA,EAAa,CAAE,gBAAiB,GAAM,WAAY,GAAI,WAAY,GAAM,EAC3F,IAAIA,EAAa,CAAE,WAAY,CAAC,EAAG,WAAY,EAAA,CAAM,EACzC,IAAIE,GAAiB,CAAE,gBAAiB,GAAM,WAAY,CAAC,CAAA,CAAG,EACxD,IAAIA,GAAiB,CAAE,gBAAiB,GAAM,WAAY,GAAI,WAAY,GAAM,EAC/F,IAAIA,GAAiB,CAAE,WAAY,CAAC,EAAG,WAAY,EAAA,CAAM,EAE5E,IAAI,MAEtB,MAAM,IAAIP,GAAgBG,IAAa,KAAK,UAAW,KAAK,KAAK,EAAE,IAAI,CAAE,KAAM,MAAQ,CAAA,EACvF,MAAM,IAAIH,GAAgBG,IAAaC,EAAY,OAAO,KAAKA,CAAW,EAAGA,EAAY,OAAO,KAAKA,CAAW,CAAC,EAAE,IAAI,CAAE,KAAM,OAAQ,EACvI,MAAM,IAAIJ,GAAgBG,IAAaG,EAAe,OAAO,KAAKA,CAAc,EAAGA,EAAe,OAAO,KAAKA,CAAc,CAAC,EAAE,IAAI,CAAE,KAAM,UAAW,CA6B1J","x_google_ignoreList":[0,1]}