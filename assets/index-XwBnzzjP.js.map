{"version":3,"file":"index-XwBnzzjP.js","sources":["../../../.yarn/cache/msgpackr-npm-1.10.0-40ff8e56d8-2f4330a5ce.zip/node_modules/msgpackr/unpack.js","../../../.yarn/cache/msgpackr-npm-1.10.0-40ff8e56d8-2f4330a5ce.zip/node_modules/msgpackr/pack.js","../../bench/serializers/index.ts"],"sourcesContent":["var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read().toString()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(property => property.toString()) // ensure that all keys are strings and that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= 8n;\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n}\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.useBigIntExtension && value < 2n**(1023n) && value > -(2n**(1023n))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42 // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & 0xffn;\n\t\t\t\t\t\t\talignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= 8n;\n\t\t\t\t\t\t} while (!((value === 0n || value === -1n) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension or set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// craete reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\t\t\n\t\tconst writeObject = checkUseRecords ? (object, safePrototype) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object,safePrototype) : writePlainObject(object,safePrototype)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048","'use strict';\n\nimport * as cbor from \"cbor-x\";\nimport * as msgpackr from 'msgpackr';\n\nimport { bench, Benchmark, BenchSuite } from \"../../src/ts/bench\";\n// import 'crypto'\n// import { randomBytes } from \"crypto\";\n\nexport async function main() {\n    // '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17'\n    // '\\x16\\x00\\x00\\x00q\\xcf\\xc6*\\x00\\x00\\x00\\x00\\n\\x00\\xdaR\\xd7\\xc2\\xab\\xdf\\x8a\\x0776\\xfa\\x9adT?\\x14\\x88a(v'\n    // '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\'\n    // bench(\"text encoder 1\", () => {\n    //     stringToByteArray('\\x16\\x00\\x00\\x00q\\xcf\\xc6*\\x00\\x00\\x00\\x00\\n\\x00\\xdaR\\xd7\\xc2\\xab\\xdf\\x8a\\x0776\\xfa\\x9adT?\\x14\\x88a(v')\n    // })\n\n    // bench(\"text decoder 1\", () => {\n    //     byteArrayToString(aaa)\n    // })\n    // bench(\"stringToByteArray 2\", () => {\n    //     stringToByteArray('\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17')\n    // }, iterations * 10)\n\n    // bench(\"text encoder 2\", () => {\n    //     new TextEncoder().encode('\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17')\n    // }, iterations)\n\n    // let x = \"123\";\n    // let x = new Array(n).fill(7);\n    // let x = { test1ffffffffffffffffffff: 3, test2: 4, tesdf: 8 };\n    // let x = { a: 3, b: 4, c: 8 };\n    // let z = '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17'\n    // let x = stringToByteArray(z)\n    // let zz = new Uint32Array([1, 2, 3, 4, 5, 6, 7, 8])\n    // let x = [34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]\n    // let x = new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23])\n    // let x = { a: 1000, b: true, c: { d: { e: { f: 1000 } } }, z: new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]) }\n    // let x = { var1a: 4294967295, var1ab: true, var1ac: { var1ad: { var1ae: { var1af: 4294967295 } } } }\n    // let x = true\n    // let x = \"lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.\"\n\n    // let x = 4294967295;\n    // let x = 10000;\n    // let x = { a: 1, b: 2, c: { d: { e: 3 } } };\n\n    // demos(() => crypto.getRandomValues(x))\n    // demos(() => crypto.getRandomValues(new Uint8Array(100)))\n    await benchAllSerializers(() => { return { a: 1000, b: true, c: { d: { e: { f: 1000 } } }, z: new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]) } })\n    // demos(() => { return { a: 1, b: 2, c: { d: { e: 3 } } } })\n}\n\nexport class SerializerBench<T, K extends (Uint8Array | string)> extends BenchSuite {\n    encode: ((data: any) => K)\n    decode: ((bytes: K) => any)\n    data: T\n    encodedData: K\n\n    constructor(data: T, encode: ((data: any) => K), decode: ((bytes: K) => any)) {\n        super()\n        this.encode = encode\n        this.decode = decode\n        this.data = data\n        this.encodedData = encode(data)\n    }\n\n    async encoding() {\n        return this.encode(this.data)\n    }\n\n    async decoding() {\n        return this.decode(this.encodedData)\n    }\n}\n\nexport const benchAllSerializers = async <T>(makeValue: () => T) => {\n    let cborEncoder = new cbor.Encoder()\n    let msgpackEncoder = new msgpackr.Encoder()\n    let cborStructuredCloneEncoder = new cbor.Encoder({ structuredClone: true })\n    let msgpackStructuredCloneEncoder = new msgpackr.Encoder({ structuredClone: true })\n    let cborStructuredCloneRecordEncoder = new cbor.Encoder({ structuredClone: true, useRecords: true })\n    let msgpackStructuredCloneRecordEncoder = new msgpackr.Encoder({ structuredClone: true, useRecords: true })\n    let cborStructuredCloneStructuresEncoder = new cbor.Encoder({ structuredClone: true, structures: [] })\n    let cborStructuredCloneRecordStructuresEncoder = new cbor.Encoder({ structuredClone: true, structures: [], useRecords: true })\n    let cborRecordStructuresEncoder = new cbor.Encoder({ structures: [], useRecords: true })\n    let msgpackStructuredCloneStructuresEncoder = new msgpackr.Encoder({ structuredClone: true, structures: [] })\n    let msgpackStructuredCloneRecordStructuresEncoder = new msgpackr.Encoder({ structuredClone: true, structures: [], useRecords: true })\n    let msgpackRecordStructuresEncoder = new msgpackr.Encoder({ structures: [], useRecords: true })\n\n    let values: T[] = new Array<T>()\n\n    await new SerializerBench(makeValue(), JSON.stringify, JSON.parse).run({ name: \"JSON\" })\n    await new SerializerBench(makeValue(), cborEncoder.encode.bind(cborEncoder), cborEncoder.decode.bind(cborEncoder)).run({ name: \"CBOR\" })\n    await new SerializerBench(makeValue(), msgpackEncoder.encode.bind(msgpackEncoder), msgpackEncoder.decode.bind(msgpackEncoder)).run({ name: \"MSGPack\" })\n\n    // console.log(await bench(x.encoding, { this: x }))\n    // console.log(await bench(x.encoding.bind(x)))\n\n    // await benchSerializer(\"JSON\", values, makeValue, JSON.stringify, JSON.parse)\n\n    // await benchSerializer(\"CBOR\", values, makeValue, cborEncoder.encode.bind(cborEncoder), cborEncoder.decode.bind(cborEncoder))\n\n    // await benchSerializer(\"CBOR - structured clone\", values, makeValue, cborStructuredCloneEncoder.encode.bind(cborStructuredCloneEncoder), cborStructuredCloneEncoder.decode.bind(cborStructuredCloneEncoder))\n\n    // // benchSerializer(\"CBOR - structured clone + record\", values, makeValue, cborStructuredCloneRecordEncoder.encode.bind(cborStructuredCloneRecordEncoder), cborStructuredCloneRecordEncoder.decode.bind(cborStructuredCloneRecordEncoder))\n\n    // // benchSerializer(\"CBOR - structured clone + structures\", values, makeValue, cborStructuredCloneStructuresEncoder.encode.bind(cborStructuredCloneStructuresEncoder), cborStructuredCloneStructuresEncoder.decode.bind(cborStructuredCloneStructuresEncoder))\n\n    // benchSerializer(\"CBOR - structured clone + record + structures\", values, makeValue, cborStructuredCloneRecordStructuresEncoder.encode.bind(cborStructuredCloneRecordStructuresEncoder), cborStructuredCloneRecordStructuresEncoder.decode.bind(cborStructuredCloneRecordStructuresEncoder))\n    // benchSerializer(\"CBOR - record + structures\", values, makeValue, cborRecordStructuresEncoder.encode.bind(cborRecordStructuresEncoder), cborRecordStructuresEncoder.decode.bind(cborRecordStructuresEncoder))\n\n    // // benchSerializer(\"MSGPack\", values, makeValue, msgpackEncoder.encode.bind(msgpackEncoder), msgpackEncoder.decode.bind(msgpackEncoder))\n\n    // benchSerializer(\"MSGPack - structured clone\", values, makeValue, msgpackStructuredCloneEncoder.encode.bind(msgpackStructuredCloneEncoder), msgpackStructuredCloneEncoder.decode.bind(msgpackStructuredCloneEncoder))\n\n    // // benchSerializer(\"MSGPack - structured clone + record\", values, makeValue, msgpackStructuredCloneRecordEncoder.encode.bind(msgpackStructuredCloneRecordEncoder), msgpackStructuredCloneRecordEncoder.decode.bind(msgpackStructuredCloneRecordEncoder))\n\n    // // benchSerializer(\"MSGPack - structured clone + structures\", values, makeValue, msgpackStructuredCloneStructuresEncoder.encode.bind(msgpackStructuredCloneStructuresEncoder), msgpackStructuredCloneStructuresEncoder.decode.bind(msgpackStructuredCloneStructuresEncoder))\n    // benchSerializer(\"MSGPack - structured clone + record + structures\", values, makeValue, msgpackStructuredCloneRecordStructuresEncoder.encode.bind(msgpackStructuredCloneRecordStructuresEncoder), msgpackStructuredCloneRecordStructuresEncoder.decode.bind(msgpackStructuredCloneRecordStructuresEncoder))\n    // benchSerializer(\"MSGPack - record + structures\", values, makeValue, msgpackRecordStructuresEncoder.encode.bind(msgpackRecordStructuresEncoder), msgpackRecordStructuresEncoder.decode.bind(msgpackRecordStructuresEncoder))\n    // benchSerializer(\"BSON\", x, BSON.serialize, BSON.deserialize)\n    // benchSerializer(\"EJSON\", x, toBytesFn(EJSON.stringify), EJSON.deserialize)\n}\n\nlet benchSerializer = async <T, K extends (Uint8Array | string)>(name: string, values: T[], makeValue: () => T, encode: ((data: any) => K), decode: ((bytes: K) => any)) => {\n    try {\n        let data = makeValue();\n        let encodedData = encode(data);\n        let decodedData = decode(encodedData);\n\n        var encodedDataString: string;\n        var encodedDataBytes: Uint8Array;\n\n        switch (encodedData.constructor) {\n            case Uint8Array:\n                encodedDataBytes = encodedData as Uint8Array\n                encodedDataString = byteArrayToString(encodedDataBytes)\n                break;\n            case String:\n                encodedDataString = encodedData as string\n                encodedDataBytes = stringToByteArray(encodedDataString)\n                break;\n        }\n\n        let encodedValues: K[] = [];\n\n        await bench((B) => {\n            // B.StopTimer()\n            // makeValue();\n            // B.StartTimer()\n            encode(data);\n        }, { name: `${name} - encode fixed` })\n\n        // await bench((B) => {\n        //     // B.StopTimer()\n        //     // encode(makeValue());\n        //     // B.StartTimer()\n\n        //     decode(encodedData);\n        // }, { name: `${name} - decode fixed` })\n\n        // await bench((B) => {\n        //     B.StopTimer()\n        //     let data = makeValue();\n        //     B.StartTimer()\n\n        //     encode(data);\n        // }, {\n        //     name: `${name} - encode unique`,\n        //     setupFn: (B) => {\n        //         // if (!values[B.I]) {\n        //         //     values[B.I] = makeValue()\n        //         // }\n        //     }\n        // },)\n\n\n        // await bench((B) => {\n        //     B.StopTimer()\n        //     let data = encode(makeValue());\n        //     B.StartTimer()\n\n        //     decode(data);\n        // }, {\n        //     name: `${name} - decode unique`,\n        //     setupFn: (B) => {\n        //         // if (!values[B.I]) {\n        //         //     values[B.I] = makeValue()\n        //         // }\n\n        //         // if (!encodedValues[B.I]) {\n        //         //     encodedValues[B.I] = encode(values[B.I])\n        //         //     decode(encodedValues[B.I])\n        //         // }\n        //     }\n        // })\n\n        // console.log(`${res.name}\\t${res.N.toLocaleString()} iterations\\t${Math.round(1000 * res.N / res.duration).toLocaleString()} ops/sec`)\n\n    } catch (error) {\n        console.error(error)\n    }\n}\n\nfunction table(...benches: Benchmark[]) {\n    console.table(benches.map(b => {\n        return {\n            name: b.name,\n            \"ops/sec\": Math.round(1000 * b.N / b.duration).toLocaleString(),\n        }\n    }))\n}\n\n\nfunction toBytesFn(fn: (data: any) => string) {\n    // return (data: any) => new TextEncoder().encode(fn(data))\n    return (data: any) => stringToByteArray(fn(data))\n}\n\nfunction fromBytesFn(fn: (data: string) => any) {\n    // return (bytes: Uint8Array) => fn(new TextDecoder().decode(bytes))\n    return (bytes: Uint8Array) => fn(byteArrayToString(bytes))\n}\n\nfunction stringToByteArray(str: string) {\n    const byteArray = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        byteArray[i] = str.charCodeAt(i);\n    }\n\n    return byteArray;\n}\n\nfunction byteArrayToString(bytes: Uint8Array) {\n    return String.fromCharCode(...bytes)\n}\n\n// function stringToByteArray2(str: string) {\n//     return new TextEncoder().encode(str)\n// }\n\n// let textEncoder = new TextEncoder()\n// function stringToByteArray3(str: string) {\n//     return textEncoder.encode(str)\n// }\n\n\n// function byteArrayToString2(bytes: Uint8Array) {\n//     return new TextDecoder().decode(bytes)\n// }\n\n\n// let textDecoder = new TextDecoder()\n// function byteArrayToString3(bytes: Uint8Array) {\n//     return textDecoder.decode(bytes)\n// }\n\n"],"names":["decoder","src","srcEnd","TextDecoder","error","currentStructures","srcString","bundledStrings","referenceMap","dataView","position","currentUnpackr","srcStringStart","srcStringEnd","currentExtensions","defaultOptions","useRecords","mapsAsObjects","C1Type","C1","name","sequentialMode","inlineObjectReadThreshold","Function","Infinity","Unpackr","constructor","options","sequential","trusted","structures","maxSharedStructures","sharedLength","length","getStructures","uninitialized","int64AsNumber","int64AsType","Object","assign","this","unpack","source","saveState","clearSource","prototype","call","buffer","ArrayBuffer","Buffer","from","Uint8Array","end","start","position$1","bundledStrings$1","DataView","byteOffset","byteLength","Error","checkedRead","unpackMultiple","forEach","values","lastPosition","size","value","defaultUnpackr","push","_mergeStructures","loadedStructures","existingStructures","isFrozen","map","structure","slice","i","l","isShared","highByte","id","existing","restoreStructures","decode","result","randomAccessStructure","read","postBundlePosition","jsonView","JSON","stringify","_","RangeError","message","startsWith","incomplete","token","loadStructures","createStructureReader","object","key","readKey","Map","set","array","Array","freezeData","freeze","string","shortStringInJS","longStringInJS","readFixedString","position1","position0","readBin","getUint16","getUint32","readExt","getFloat32","useFloat32","multiplier","mult10","getFloat64","getBigUint64","toString","BigInt","Number","getInt8","getInt16","getInt32","getBigInt64","recordDefinition","extension","noBuffer","subarray","readString8","readString16","readString32","readArray","readMap","validName","firstId","readObject","count","test","join","createSecondByteReader","read0","readStringJS","units","byte1","byte2","byte3","unit","fromCharCode","apply","String","bytes","byte","a","b","c","d","e","f","g","h","j","k","m","n","o","readOnlyJSString","copyBuffers","type","readPosition","keyCache","chunk","entry","checkPosition","property","firstByte","existingStructure","data","errors","TypeError","ReferenceError","target","refEntry","targetProperties","used","get","Set","typedArrays","glbl","globalThis","window","typeCode","typedArrayName","RegExp","TEMP_BUNDLE","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedStructuresContents","savedPackr","savedSequentialMode","splice","dataSize","dataPosition","Date","Math","floor","textEncoder","extensions","extensionClasses","f32Array","Float32Array","TextEncoder","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","keysTarget","targetView","safeEnd","hasNonLatin","RECORD_SYMBOL","Symbol","Packr","hasSharedUpdate","super","offset","encodeUtf8","utf8Write","encodeInto","written","packr","isSequential","hasSharedStructures","saveStructures","structuredClone","moreTypes","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","pack","encode","encodeOptions","RESERVE_START_SPACE","bundleStrings","transitions","create","keys","nextTransition","transition","lastNamedStructuresLength","nextId","encodingError","writeStruct","lastBundle","writeBundles","idsToInsert","sort","incrementPosition","insertionPoint","stringsPosition","setUint32","previous","makeRoom","serialized","distanceToMove","lastEnd","pop","copyWithin","insertIds","REUSE_BUFFER_MODE","returnBuffer","newSharedData","isCompatible","compatible","prepareStructures","RESET_BUFFER_MODE","resetStructures","packArray","headerSize","strLength","extStart","maxBytes","setUint16","twoByte","c1","c2","strPosition","charCodeAt","setInt16","setInt32","xShifted","setFloat32","setFloat64","referee","writeObject","mapAsEmptyObject","entryValue","write","writeResult","isArray","currentTarget","currentTargetView","currentPosition","writeExtensionData","toJSON","json","writeFunction","hasOwnProperty","setBigInt64","setBigUint64","largeBigIntToFloat","useBigIntExtension","alignedSign","encodeUndefinedAsNil","writePlainObject","variableMapSize","coercibleKeyAsNumber","num","isNaN","safePrototype","objectOffset","writeRecord","progressiveRecords","wroteKeys","lastTransition","newTransitions","newRecord","insertNewRecord","recordId","__keys__","checkUseRecords","newSize","min","round","max","newBuffer","copy","shouldShareStructure","nextOwnId","shift","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","writeStructSlots","notifySharedUpdate","startTarget","useBuffer","clearSharedData","typedStructs","writeExtBuffer","typedArray","allocateForWrite","writeBuffer","writeStrings","getPrototypeOf","date","seconds","getTime","useTimestamp32","getMilliseconds","onInvalidDate","setAsEmptyObject","regex","flags","arrayBuffer","indexOf","defaultPackr","Encoder","async","main","benchAllSerializers","z","SerializerBench","BenchSuite","encodedData","encoding","decoding","makeValue","cborEncoder","cbor.Encoder","msgpackEncoder","msgpackr.Encoder","parse","run","bind"],"mappings":"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","x_google_ignoreList":[0,1]}