{"version":3,"file":"index-2h9Z-4Ba.js","sources":["../../../.yarn/cache/cbor-x-npm-1.5.8-22457734f0-5e62849252.zip/node_modules/cbor-x/decode.js","../../../.yarn/cache/cbor-x-npm-1.5.8-22457734f0-5e62849252.zip/node_modules/cbor-x/encode.js","../../../.yarn/cache/msgpackr-npm-1.10.1-5c5ff5c553-9fc78c7843.zip/node_modules/msgpackr/unpack.js","../../../.yarn/cache/msgpackr-npm-1.10.1-5c5ff5c553-9fc78c7843.zip/node_modules/msgpackr/pack.js","../../bench/serializers/index.ts"],"sourcesContent":["let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key !== 'object') return key.toString()\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, null); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n","var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number') return property.toString();\n\tthrow new Error('Invalid property type for record', typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= 8n;\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n}\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.useBigIntExtension && value < 2n**(1023n) && value > -(2n**(1023n))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42 // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & 0xffn;\n\t\t\t\t\t\t\talignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= 8n;\n\t\t\t\t\t\t} while (!((value === 0n || value === -1n) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension or set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// craete reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\t\t\n\t\tconst writeObject = checkUseRecords ? (object, safePrototype) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object,safePrototype) : writePlainObject(object,safePrototype)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048","'use strict';\n\nimport * as cbor from \"cbor-x\";\nimport * as msgpackr from 'msgpackr';\n\nimport { bench, Benchmark, BenchSuite } from \"../../src/ts/bench\";\n// import 'crypto'\n// import { randomBytes } from \"crypto\";\n\nexport async function main() {\n    // '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17'\n    // '\\x16\\x00\\x00\\x00q\\xcf\\xc6*\\x00\\x00\\x00\\x00\\n\\x00\\xdaR\\xd7\\xc2\\xab\\xdf\\x8a\\x0776\\xfa\\x9adT?\\x14\\x88a(v'\n    // '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\'\n    // bench(\"text encoder 1\", () => {\n    //     stringToByteArray('\\x16\\x00\\x00\\x00q\\xcf\\xc6*\\x00\\x00\\x00\\x00\\n\\x00\\xdaR\\xd7\\xc2\\xab\\xdf\\x8a\\x0776\\xfa\\x9adT?\\x14\\x88a(v')\n    // })\n\n    // bench(\"text decoder 1\", () => {\n    //     byteArrayToString(aaa)\n    // })\n    // bench(\"stringToByteArray 2\", () => {\n    //     stringToByteArray('\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17')\n    // }, iterations * 10)\n\n    // bench(\"text encoder 2\", () => {\n    //     new TextEncoder().encode('\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17')\n    // }, iterations)\n\n    // let x = \"123\";\n    // let x = new Array(n).fill(7);\n    // let x = { test1ffffffffffffffffffff: 3, test2: 4, tesdf: 8 };\n    // let x = { a: 3, b: 4, c: 8 };\n    // let z = '\"\\x00\\x00\\x00\\xf1b\\\\\\xbf\\xff\\xff\\xff\\xff\\x04\\x00m\\xea\\x06\\x14m\\xf7\\xd1\\x0bk\\x1e\"\\x0fn\\xdc\\xa32\\xcc\\x03\\x81\\x1e\\xad+\\x00\\x02VhA?\\x1b\\xbf\\x17\\x17'\n    // let x = stringToByteArray(z)\n    // let zz = new Uint32Array([1, 2, 3, 4, 5, 6, 7, 8])\n    // let x = [34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]\n    // let x = new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23])\n    // let x = { a: 1000, b: true, c: { d: { e: { f: 1000 } } }, z: new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]) }\n    // let x = { var1a: 4294967295, var1ab: true, var1ac: { var1ad: { var1ae: { var1af: 4294967295 } } } }\n    // let x = true\n    // let x = \"lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.\"\n\n    // let x = 4294967295;\n    // let x = 10000;\n    // let x = { a: 1, b: 2, c: { d: { e: 3 } } };\n\n    // demos(() => crypto.getRandomValues(x))\n    // demos(() => crypto.getRandomValues(new Uint8Array(100)))\n    await benchAllSerializers(() => { return { a: 1000, b: true, c: { d: { e: { f: 1000 } } }, z: new Uint8Array([34, 0, 0, 0, 241, 98, 92, 191, 255, 255, 255, 255, 4, 0, 109, 234, 6, 20, 109, 247, 209, 11, 107, 30, 34, 15, 110, 220, 163, 50, 204, 3, 129, 30, 173, 43, 0, 2, 86, 104, 65, 63, 27, 191, 23, 23]) } })\n    // demos(() => { return { a: 1, b: 2, c: { d: { e: 3 } } } })\n}\n\nexport class SerializerBench<T, K extends (Uint8Array | string)> extends BenchSuite {\n    encode: ((data: any) => K)\n    decode: ((bytes: K) => any)\n    data: T\n    encodedData: K\n\n    constructor(data: T, encode: ((data: any) => K), decode: ((bytes: K) => any)) {\n        super()\n        this.encode = encode\n        this.decode = decode\n        this.data = data\n        this.encodedData = encode(data)\n    }\n\n    async encoding() {\n        return this.encode(this.data)\n    }\n\n    async decoding() {\n        return this.decode(this.encodedData)\n    }\n}\n\nexport const benchAllSerializers = async <T>(makeValue: () => T) => {\n    let cborEncoder = new cbor.Encoder()\n    let msgpackEncoder = new msgpackr.Encoder()\n    let cborStructuredCloneEncoder = new cbor.Encoder({ structuredClone: true })\n    let msgpackStructuredCloneEncoder = new msgpackr.Encoder({ structuredClone: true })\n    let cborStructuredCloneRecordEncoder = new cbor.Encoder({ structuredClone: true, useRecords: true })\n    let msgpackStructuredCloneRecordEncoder = new msgpackr.Encoder({ structuredClone: true, useRecords: true })\n    let cborStructuredCloneStructuresEncoder = new cbor.Encoder({ structuredClone: true, structures: [] })\n    let cborStructuredCloneRecordStructuresEncoder = new cbor.Encoder({ structuredClone: true, structures: [], useRecords: true })\n    let cborRecordStructuresEncoder = new cbor.Encoder({ structures: [], useRecords: true })\n    let msgpackStructuredCloneStructuresEncoder = new msgpackr.Encoder({ structuredClone: true, structures: [] })\n    let msgpackStructuredCloneRecordStructuresEncoder = new msgpackr.Encoder({ structuredClone: true, structures: [], useRecords: true })\n    let msgpackRecordStructuresEncoder = new msgpackr.Encoder({ structures: [], useRecords: true })\n\n    let values: T[] = new Array<T>()\n\n    await new SerializerBench(makeValue(), JSON.stringify, JSON.parse).run({ name: \"JSON\" })\n    await new SerializerBench(makeValue(), cborEncoder.encode.bind(cborEncoder), cborEncoder.decode.bind(cborEncoder)).run({ name: \"CBOR\" })\n    await new SerializerBench(makeValue(), msgpackEncoder.encode.bind(msgpackEncoder), msgpackEncoder.decode.bind(msgpackEncoder)).run({ name: \"MSGPack\" })\n\n    // console.log(await bench(x.encoding, { this: x }))\n    // console.log(await bench(x.encoding.bind(x)))\n\n    // await benchSerializer(\"JSON\", values, makeValue, JSON.stringify, JSON.parse)\n\n    // await benchSerializer(\"CBOR\", values, makeValue, cborEncoder.encode.bind(cborEncoder), cborEncoder.decode.bind(cborEncoder))\n\n    // await benchSerializer(\"CBOR - structured clone\", values, makeValue, cborStructuredCloneEncoder.encode.bind(cborStructuredCloneEncoder), cborStructuredCloneEncoder.decode.bind(cborStructuredCloneEncoder))\n\n    // // benchSerializer(\"CBOR - structured clone + record\", values, makeValue, cborStructuredCloneRecordEncoder.encode.bind(cborStructuredCloneRecordEncoder), cborStructuredCloneRecordEncoder.decode.bind(cborStructuredCloneRecordEncoder))\n\n    // // benchSerializer(\"CBOR - structured clone + structures\", values, makeValue, cborStructuredCloneStructuresEncoder.encode.bind(cborStructuredCloneStructuresEncoder), cborStructuredCloneStructuresEncoder.decode.bind(cborStructuredCloneStructuresEncoder))\n\n    // benchSerializer(\"CBOR - structured clone + record + structures\", values, makeValue, cborStructuredCloneRecordStructuresEncoder.encode.bind(cborStructuredCloneRecordStructuresEncoder), cborStructuredCloneRecordStructuresEncoder.decode.bind(cborStructuredCloneRecordStructuresEncoder))\n    // benchSerializer(\"CBOR - record + structures\", values, makeValue, cborRecordStructuresEncoder.encode.bind(cborRecordStructuresEncoder), cborRecordStructuresEncoder.decode.bind(cborRecordStructuresEncoder))\n\n    // // benchSerializer(\"MSGPack\", values, makeValue, msgpackEncoder.encode.bind(msgpackEncoder), msgpackEncoder.decode.bind(msgpackEncoder))\n\n    // benchSerializer(\"MSGPack - structured clone\", values, makeValue, msgpackStructuredCloneEncoder.encode.bind(msgpackStructuredCloneEncoder), msgpackStructuredCloneEncoder.decode.bind(msgpackStructuredCloneEncoder))\n\n    // // benchSerializer(\"MSGPack - structured clone + record\", values, makeValue, msgpackStructuredCloneRecordEncoder.encode.bind(msgpackStructuredCloneRecordEncoder), msgpackStructuredCloneRecordEncoder.decode.bind(msgpackStructuredCloneRecordEncoder))\n\n    // // benchSerializer(\"MSGPack - structured clone + structures\", values, makeValue, msgpackStructuredCloneStructuresEncoder.encode.bind(msgpackStructuredCloneStructuresEncoder), msgpackStructuredCloneStructuresEncoder.decode.bind(msgpackStructuredCloneStructuresEncoder))\n    // benchSerializer(\"MSGPack - structured clone + record + structures\", values, makeValue, msgpackStructuredCloneRecordStructuresEncoder.encode.bind(msgpackStructuredCloneRecordStructuresEncoder), msgpackStructuredCloneRecordStructuresEncoder.decode.bind(msgpackStructuredCloneRecordStructuresEncoder))\n    // benchSerializer(\"MSGPack - record + structures\", values, makeValue, msgpackRecordStructuresEncoder.encode.bind(msgpackRecordStructuresEncoder), msgpackRecordStructuresEncoder.decode.bind(msgpackRecordStructuresEncoder))\n    // benchSerializer(\"BSON\", x, BSON.serialize, BSON.deserialize)\n    // benchSerializer(\"EJSON\", x, toBytesFn(EJSON.stringify), EJSON.deserialize)\n}\n\nlet benchSerializer = async <T, K extends (Uint8Array | string)>(name: string, values: T[], makeValue: () => T, encode: ((data: any) => K), decode: ((bytes: K) => any)) => {\n    try {\n        let data = makeValue();\n        let encodedData = encode(data);\n        let decodedData = decode(encodedData);\n\n        var encodedDataString: string;\n        var encodedDataBytes: Uint8Array;\n\n        switch (encodedData.constructor) {\n            case Uint8Array:\n                encodedDataBytes = encodedData as Uint8Array\n                encodedDataString = byteArrayToString(encodedDataBytes)\n                break;\n            case String:\n                encodedDataString = encodedData as string\n                encodedDataBytes = stringToByteArray(encodedDataString)\n                break;\n        }\n\n        let encodedValues: K[] = [];\n\n        await bench((B) => {\n            // B.StopTimer()\n            // makeValue();\n            // B.StartTimer()\n            encode(data);\n        }, { name: `${name} - encode fixed` })\n\n        // await bench((B) => {\n        //     // B.StopTimer()\n        //     // encode(makeValue());\n        //     // B.StartTimer()\n\n        //     decode(encodedData);\n        // }, { name: `${name} - decode fixed` })\n\n        // await bench((B) => {\n        //     B.StopTimer()\n        //     let data = makeValue();\n        //     B.StartTimer()\n\n        //     encode(data);\n        // }, {\n        //     name: `${name} - encode unique`,\n        //     setupFn: (B) => {\n        //         // if (!values[B.I]) {\n        //         //     values[B.I] = makeValue()\n        //         // }\n        //     }\n        // },)\n\n\n        // await bench((B) => {\n        //     B.StopTimer()\n        //     let data = encode(makeValue());\n        //     B.StartTimer()\n\n        //     decode(data);\n        // }, {\n        //     name: `${name} - decode unique`,\n        //     setupFn: (B) => {\n        //         // if (!values[B.I]) {\n        //         //     values[B.I] = makeValue()\n        //         // }\n\n        //         // if (!encodedValues[B.I]) {\n        //         //     encodedValues[B.I] = encode(values[B.I])\n        //         //     decode(encodedValues[B.I])\n        //         // }\n        //     }\n        // })\n\n        // console.log(`${res.name}\\t${res.N.toLocaleString()} iterations\\t${Math.round(1000 * res.N / res.duration).toLocaleString()} ops/sec`)\n\n    } catch (error) {\n        console.error(error)\n    }\n}\n\nfunction table(...benches: Benchmark[]) {\n    console.table(benches.map(b => {\n        return {\n            name: b.name,\n            \"ops/sec\": Math.round(1000 * b.N / b.duration).toLocaleString(),\n        }\n    }))\n}\n\n\nfunction toBytesFn(fn: (data: any) => string) {\n    // return (data: any) => new TextEncoder().encode(fn(data))\n    return (data: any) => stringToByteArray(fn(data))\n}\n\nfunction fromBytesFn(fn: (data: string) => any) {\n    // return (bytes: Uint8Array) => fn(new TextDecoder().decode(bytes))\n    return (bytes: Uint8Array) => fn(byteArrayToString(bytes))\n}\n\nfunction stringToByteArray(str: string) {\n    const byteArray = new Uint8Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n        byteArray[i] = str.charCodeAt(i);\n    }\n\n    return byteArray;\n}\n\nfunction byteArrayToString(bytes: Uint8Array) {\n    return String.fromCharCode(...bytes)\n}\n\n// function stringToByteArray2(str: string) {\n//     return new TextEncoder().encode(str)\n// }\n\n// let textEncoder = new TextEncoder()\n// function stringToByteArray3(str: string) {\n//     return textEncoder.encode(str)\n// }\n\n\n// function byteArrayToString2(bytes: Uint8Array) {\n//     return new TextDecoder().decode(bytes)\n// }\n\n\n// let textDecoder = new TextDecoder()\n// function byteArrayToString3(bytes: Uint8Array) {\n//     return textDecoder.decode(bytes)\n// }\n\n"],"names":["decoder","src","srcEnd","TextDecoder","error","position","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","STOP_CODE","currentStructures","srcString","bundledStrings","referenceMap","packedValues","dataView","restoreMapsAsObject","currentDecoder","srcStringStart","srcStringEnd","currentExtensions","currentExtensionRanges","defaultOptions","useRecords","mapsAsObjects","sequentialMode","inlineObjectReadThreshold","Function","inlineObjectReadThreshold$1","Infinity","Decoder","constructor","options","keyMap","_keyMap","getStructures","getShared","structures","uninitialized","this","mapKey","Map","k","v","Object","entries","set","assign","decodeKey","key","get","encodeKey","hasOwnProperty","encodeKeys","rec","map","decodeKeys","name","_mapKey","res","forEach","safeKey","has","mapDecode","source","end","decode","r","saveState","clearSource$1","prototype","call","srcEnd$1","length","position$3","srcStringEnd$1","srcString$1","bundledStrings$3","src$1","dataView$1","DataView","buffer","byteOffset","byteLength","Uint8Array","Error","sharedValues","pack","Array","maxPrivatePackedValues","concat","checkedRead","decodeMultiple","values","lastPosition","size","sequentialMode$1","value","defaultDecoder","push","result","read","postBundlePosition","incomplete","currentStructures$1","referenceMap$1","RangeError","message","startsWith","token","majorType","byte0","byte1","exponent","NaN","abs","u8Array","f32Array","getFloat16","getUint16","getFloat32","useFloat32","multiplier","mult10","getUint32","getFloat64","int64AsNumber","getBigUint64","array","i","join","Buffer","object","copyBuffers","slice","subarray","string","shortStringInJS","start","bytes","byte","fromCharCode","apply","String","longStringInJS","readFixedString","structure","createStructureReader","readJustLength","id","recordDefinition","recordDefinition$1","bundlePosition","bundleLength","dataPosition","readStringJS","position0","position1","readBundleExt","loadShared","extension","handlesRead","input","Tag","packedValue","getPackedValues","isNaN","validName","slowReads","compiledReader","propertyCount","next","test","JSON","stringify","toString","units","byte2","byte3","unit","a","b","c","d","e","f","g","h","j","l","m","n","o","Float32Array","tag","dateString","Date","epochSec","Math","round","BigInt","fraction","exp","log","existingStructure","isShared","restoreStructures","data","glbl","RegExp","packedTable","newPackedValues","prefixes","suffixes","combine","target","refEntry","targetProperties","used","Set","version","isLittleEndianMachine","Uint16Array","typedArrays","Uint8ClampedArray","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float64Array","typedArrayTags","registerTypedArray","TypedArray","bytesPerElement","dvMethod","BYTES_PER_ELEMENT","littleEndian","sizeShift","currentExtensions$1","dv","elements","ta","method","sharedData","updatedStructures","sharedVersion","splice","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","srcStringStart$1","clearSource","mult10$1","floor","textEncoder","extensions","extensionClasses","TextEncoder","globalThis","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","throwOnIterable","targetView","safeEnd","hasNonLatin","RECORD_SYMBOL","Symbol","sharedStructures","hasSharedUpdate","super","offset","encodeUtf8","utf8Write","maxBytes","encodeInto","written","encoder","hasSharedStructures","saveStructures","maxSharedStructures","isSequential","sequential","saveShared","samplingPackedValues","packedObjectMap","sharedPackedObjectMap","create","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","mapEncode","encodeOptions","_mapped","encode","target$1","position$2","REUSE_BUFFER_MODE","useSelfDescribedHeader","targetView$1","setUint32","structuredClone","bundleStrings","bundledStrings$2","sharedStructuresLength","transitions","keys","nextTransition","transition","nextId","maxValues","objectMap","findRepetitiveStrings","writeArrayHeader","valuesArray","THROW_ON_ITERABLE","writeBundles","idsToInsert","makeRoom","serialized","distanceToMove","lastEnd","sort","referee","references","pop","copyWithin","insertIds","returnBuffer","updateSharedData","RESET_BUFFER_MODE","findCommonStringsToPack","threshold","status","count","type","packedPosition","headerSize","strLength","extStart","twoByte","c1","c2","strPosition","charCodeAt","alwaysUseFloat","xShifted","setFloat32","setFloat64","setUint16","writeObject","useTag259ForMaps","entryValue","getTag","iterator","iteratorNotHandled","entry","asyncIterator","isBlob","useToJSON","toJSON","json","setBigUint64","largeBigIntToFloat","Number","variableMapSize","vals","safePrototype","objectOffset","parentRecordId","newTransitions","recordId","__keys__","shift","newSize","min","max","newBuffer","copy","chunkThreshold","continuedChunkThreshold","encodeObjectAsIterable","iterateProperties","finalIterable","writeEntityLength","tryEncode","element","restart","restartEncoding","startEncoding","encodeIterable","async","encodeObjectAsAsyncIterable","encodedValue","reader","stream","getReader","done","asyncValue","encodeAsIterable","encodeAsAsyncIterable","useBuffer","clearSharedData","lastVersion","structuresCopy","SharedData","saveResults","existingShared","majorValue","BlobConstructor","Blob","toStringTag","packedStatus","includeKeys","console","typedArrayEncoder","typedArray","from","writeBuffer","writeStrings","ArrayBuffer","date","seconds","getTime","useTimestamp32","getMilliseconds","regex","flags","arrayBuffer","tagUint8Array","definitions","unshift","defaultEncoder","Encoder","currentUnpackr","C1Type","C1","Unpackr","trusted","sharedLength","int64AsType","unpack","position$1","bundledStrings$1","unpackMultiple","defaultUnpackr","_mergeStructures","loadedStructures","existingStructures","isFrozen","highByte","existing","randomAccessStructure","jsonView","_","loadStructures","readKey","freezeData","freeze","readBin","readExt","getInt8","getInt16","getInt32","getBigInt64","noBuffer","readString8","readString16","readString32","readArray","readMap","firstId","readObject","createSecondByteReader","read0","readOnlyJSString","readPosition","keyCache","asSafeString","chunk","checkPosition","property","firstByte","errors","TypeError","ReferenceError","window","typeCode","typedArrayName","TEMP_BUNDLE","savedStructuresContents","savedPackr","dataSize","keysTarget","Packr","packr","moreTypes","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","RESERVE_START_SPACE","lastNamedStructuresLength","encodingError","writeStruct","lastBundle","incrementPosition","insertionPoint","stringsPosition","previous","newSharedData","isCompatible","compatible","prepareStructures","resetStructures","packArray","setInt16","setInt32","mapAsEmptyObject","write","writeResult","isArray","currentTarget","currentTargetView","currentPosition","writeExtensionData","writeFunction","setBigInt64","useBigIntExtension","alignedSign","encodeUndefinedAsNil","writePlainObject","coercibleKeyAsNumber","num","writeRecord","progressiveRecords","wroteKeys","lastTransition","newRecord","insertNewRecord","checkUseRecords","shouldShareStructure","nextOwnId","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","writeStructSlots","notifySharedUpdate","startTarget","typedStructs","writeExtBuffer","allocateForWrite","getPrototypeOf","onInvalidDate","setAsEmptyObject","indexOf","defaultPackr","main","benchAllSerializers","z","SerializerBench","BenchSuite","encodedData","encoding","decoding","makeValue","cborEncoder","cbor.Encoder","msgpackEncoder","msgpackr.Encoder","parse","run","bind"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}