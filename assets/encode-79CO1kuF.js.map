{"version":3,"file":"encode-79CO1kuF.js","sources":["../../../.yarn/cache/cbor-x-npm-1.5.6-e57ee4fceb-103e75419f.zip/node_modules/cbor-x/decode.js","../../../.yarn/cache/cbor-x-npm-1.5.6-e57ee4fceb-103e75419f.zip/node_modules/cbor-x/encode.js"],"sourcesContent":["let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\treturn key === '__proto__' ? '__proto_' : key\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, null); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n"],"names":["decoder","src","srcEnd","TextDecoder","error","position","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","STOP_CODE","currentStructures","srcString","bundledStrings","referenceMap","packedValues","dataView","restoreMapsAsObject","currentDecoder","srcStringStart","srcStringEnd","currentExtensions","currentExtensionRanges","defaultOptions","useRecords","mapsAsObjects","sequentialMode","inlineObjectReadThreshold","Function","Infinity","Decoder","constructor","options","keyMap","_keyMap","undefined","getStructures","getShared","structures","uninitialized","this","mapKey","Map","k","v","Object","entries","set","assign","decodeKey","key","get","encodeKey","hasOwnProperty","encodeKeys","rec","map","decodeKeys","name","_mapKey","res","forEach","safeKey","has","mapDecode","source","end","decode","r","saveState","clearSource","prototype","call","length","DataView","buffer","byteOffset","byteLength","Uint8Array","Error","sharedValues","pack","Array","maxPrivatePackedValues","concat","checkedRead","decodeMultiple","values","lastPosition","size","value","defaultDecoder","push","result","read","postBundlePosition","incomplete","RangeError","message","startsWith","token","majorType","byte0","byte1","exponent","NaN","abs","u8Array","f32Array","getFloat16","getUint16","getFloat32","useFloat32","multiplier","mult10","getUint32","getFloat64","int64AsNumber","getBigUint64","array","i","join","Buffer","object","copyBuffers","slice","subarray","string","shortStringInJS","start","bytes","byte","fromCharCode","apply","String","longStringInJS","readFixedString","structure","createStructureReader","readJustLength","id","recordDefinition","bundlePosition","bundleLength","dataPosition","readStringJS","position0","position1","readBundleExt","loadShared","extension","handlesRead","input","Tag","packedValue","getPackedValues","isNaN","validName","slowReads","compiledReader","propertyCount","next","test","JSON","stringify","units","byte2","byte3","unit","a","b","c","d","e","f","g","h","j","l","m","n","o","Float32Array","tag","dateString","Date","epochSec","Math","round","BigInt","fraction","exp","log","existingStructure","isShared","restoreStructures","data","glbl","RegExp","packedTable","newPackedValues","prefixes","suffixes","combine","target","refEntry","targetProperties","used","Set","version","isLittleEndianMachine","Uint16Array","typedArrays","Uint8ClampedArray","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float64Array","typedArrayTags","registerTypedArray","TypedArray","bytesPerElement","dvMethod","BYTES_PER_ELEMENT","littleEndian","sizeShift","dv","elements","ta","method","sharedData","updatedStructures","sharedVersion","splice","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","floor","textEncoder","extensions","extensionClasses","TextEncoder","globalThis","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","throwOnIterable","targetView","safeEnd","hasNonLatin","RECORD_SYMBOL","Symbol","Encoder","sharedStructures","hasSharedUpdate","super","offset","encodeUtf8","utf8Write","maxBytes","encodeInto","written","encoder","hasSharedStructures","saveStructures","maxSharedStructures","isSequential","sequential","saveShared","samplingPackedValues","packedObjectMap","sharedPackedObjectMap","create","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","mapEncode","encodeOptions","_mapped","encode","REUSE_BUFFER_MODE","useSelfDescribedHeader","setUint32","structuredClone","bundleStrings","sharedStructuresLength","transitions","keys","nextTransition","transition","nextId","maxValues","objectMap","findRepetitiveStrings","writeArrayHeader","valuesArray","THROW_ON_ITERABLE","writeBundles","idsToInsert","makeRoom","serialized","distanceToMove","lastEnd","sort","referee","references","pop","copyWithin","insertIds","returnBuffer","updateSharedData","RESET_BUFFER_MODE","findCommonStringsToPack","threshold","status","count","type","packedPosition","headerSize","strLength","extStart","twoByte","c1","c2","strPosition","charCodeAt","alwaysUseFloat","xShifted","setFloat32","setFloat64","setUint16","writeObject","useTag259ForMaps","entryValue","getTag","iterator","iteratorNotHandled","entry","asyncIterator","isBlob","useToJSON","toJSON","json","setBigUint64","largeBigIntToFloat","Number","variableMapSize","vals","safePrototype","objectOffset","parentRecordId","newTransitions","recordId","__keys__","shift","newSize","min","max","newBuffer","copy","chunkThreshold","continuedChunkThreshold","encodeObjectAsIterable","iterateProperties","finalIterable","writeEntityLength","tryEncode","element","restartEncoding","restart","startEncoding","encodeIterable","async","encodeObjectAsAsyncIterable","encodedValue","reader","stream","getReader","done","asyncValue","encodeAsIterable","encodeAsAsyncIterable","useBuffer","clearSharedData","lastVersion","structuresCopy","SharedData","saveResults","existingShared","majorValue","BlobConstructor","Blob","toStringTag","packedStatus","includeKeys","console","typedArrayEncoder","typedArray","from","writeBuffer","writeStrings","ArrayBuffer","date","seconds","getTime","useTimestamp32","getMilliseconds","regex","flags","arrayBuffer","tagUint8Array","definitions","unshift","defaultEncoder"],"mappings":"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","x_google_ignoreList":[0,1]}