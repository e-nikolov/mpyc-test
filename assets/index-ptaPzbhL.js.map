{"version":3,"file":"index-ptaPzbhL.js","sources":["../../src/ts/utils/log.ts","../../src/ts/bench/index.ts"],"sourcesContent":["\n\nexport const tableLogger = (selector = \"#out\", columns = [\"Data\"]) => (...data: any[]) => {\n    const table = ensureLogTable(selector, columns)\n\n\n    const row = table.insertRow()\n    for (let arg of data) {\n\n        const cell = row.insertCell()\n        cell.textContent = arg\n        cell.style.paddingRight = \"50px\"\n    }\n}\n\nexport const ensureLogTable = (selector = \"#out\", columns = [\"Data\"]) => {\n    const div = document.querySelector<HTMLDivElement>(selector)!\n    let existingTable = div.querySelector<HTMLTableElement>(\"table\")\n    if (existingTable) {\n        return existingTable;\n    }\n\n    const newTable = document.createElement(\"table\")\n    const headRow = newTable.createTHead().insertRow()\n    headRow.style.borderBottom = \"1px solid #ccc\"\n    for (let column of columns) {\n        headRow.insertCell().textContent = column\n    }\n    div.insertAdjacentElement(\"beforeend\", newTable)\n    return newTable\n}\n\nexport const logTable = tableLogger(\"#out\")\n\n","import { findClusterBreak } from \"@codemirror/state\"\nimport { logTable, sleep, tableLogger } from \"../utils\"\n\n\n// Ported from Go's testing.B: https://cs.opensource.google/go/go/+/refs/tags/go1.21.3:src/testing/benchmark.go;l=293\n\ntype benchOpts = Required<{\n    name?: string\n    setupFn: (b: Benchmark) => void\n    logEnabled?: boolean\n    logSelector?: string\n    runtimeGoalMS: number\n    this?: any\n}>\n\nimport 'reflect-metadata';\n\nconst METADATA_KEY = Symbol('Bench');\n\n// export function Bench() {\n\n//     return (target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) => {\n//         Reflect.defineMetadata(METADATA_KEY, true, target, propertyKey);\n//         // const originalMethod = descriptor.value;\n//         // descriptor.value = async function () {\n//         //     opts = { ...defaultOpts, ...opts }\n//         //     opts.name = originalMethod.name || \"anonymous\"\n//         //     opts.name = `${this.benchName} - ${opts.name}`\n//         //     return await bench(originalMethod.bind(this), { ...opts })\n//         // };\n//         return descriptor;\n//     }\n// }\n\nexport abstract class BenchSuite {\n    static async run2(opts: Partial<benchOpts> = {}, instance?: any) {\n        const target = instance ? Object.getPrototypeOf(instance) : this.prototype\n\n        for (const methodName of Object.getOwnPropertyNames(target)) {\n            if (methodName == \"constructor\") continue\n            await bench(target[methodName].bind(instance || target), { ...opts, name: `${opts.name || target.constructor.name} - ${methodName}` })\n            await sleep(0)\n        }\n    }\n\n    async run(opts: Partial<benchOpts> = {}) {\n        await BenchSuite.run2(opts, this)\n    }\n}\n\n\nexport const bench = async (fn: (b: Benchmark) => any, opts: Partial<benchOpts> = {}) => {\n    opts = { ...defaultOpts, ...opts }\n\n    let B = new Benchmark(fn, opts)\n\n    await B.run()\n\n    if (opts.logEnabled) {\n        B.logTable(opts.logSelector)\n    }\n\n    return B;\n}\n\nconst defaultOpts = {\n    name: \"\",\n    setupFn: () => { },\n    logEnabled: true,\n    logSelector: \"#out\",\n    runtimeGoalMS: 500,\n    this: undefined,\n}\n\nexport class Benchmark {\n    protected _N: number = 0\n    protected _I: number = 0\n    protected _duration: number = 0\n    protected benchFunc: (b: Benchmark) => any = () => { }\n    protected startTime: number = 0\n    protected timerOn: boolean = false\n    protected opts: benchOpts\n\n    get N() {\n        return this._N\n    }\n    get I() {\n        return this._I\n    }\n    get duration() {\n        return this._duration\n    }\n    get name() {\n        return this.opts.name\n    }\n\n    get result() {\n        return {\n            name: this.name,\n            N: this.N.toLocaleString,\n            duration: this.duration.toLocaleString\n        }\n    }\n\n    constructor(fn: (b: Benchmark) => any, opts: Partial<benchOpts> = {}) {\n        this.opts = { ...defaultOpts, ...opts }\n        this.benchFunc = fn\n    }\n\n    StartTimer() {\n        if (this.timerOn) {\n            return\n        }\n        this.startTime = performance.now()\n        this.timerOn = true\n    }\n    StopTimer() {\n        if (!this.timerOn) {\n            return\n        }\n\n        this._duration += performance.now() - this.startTime\n        this.timerOn = false\n    }\n    ResetTimer() {\n        if (this.timerOn) {\n            this.startTime = performance.now()\n        }\n\n        this._duration = 0\n    }\n\n    run = async () => {\n        await this.runN(1)\n\n        for (let n = 1; this._duration <= this.opts.runtimeGoalMS && n < 1e9;) {\n            let last = n;\n            // Predict required iterations.\n            let prevIters = this._N\n            let prevms = this._duration;\n            if (prevms <= 0) {\n                // Round up, to avoid div by zero.\n                prevms = 1\n            }\n\n            // Order of operations matters.\n            // For very fast benchmarks, prevIters ~= prevns.\n            // If you divide first, you get 0 or 1,\n            // which can hide an order of magnitude in execution time.\n            // So multiply first, then divide.\n            n = Math.floor(this.opts.runtimeGoalMS * prevIters / prevms)\n            // Run more iterations than we think we'll need (1.2x).\n            n += Math.floor(n / 5)\n            // Don't grow too fast in case we had timing errors previously.\n            n = Math.min(n, 100 * last)\n            // Be sure to run at least one more than last time.\n            n = Math.max(n, last + 1)\n            // Don't run more than 1e9 times.\n            n = Math.min(n, 1e9)\n            // console.log(`Running ${n.toLocaleString()} iterations`)\n            await this.runN(n)\n            // console.log(`Running ${n.toLocaleString()} iterations...done`)\n        }\n    }\n\n    protected runN = async (n: number) => {\n        this._N = n\n\n        // console.log(\"setup\")\n        for (this._I = 0; this._I < n; this._I++) {\n            this.opts.setupFn(this)\n        }\n        // console.log(\"setup...done\")\n        // console.log(\"bench\")\n        this.ResetTimer()\n        this.StartTimer()\n        for (this._I = 0; this._I < n; this._I++) {\n            // await this.benchFunc.apply(this.opts.this, [this])\n            await this.benchFunc(this)\n        }\n        this.StopTimer()\n        // console.log(\"bench...done\", this._duration.toLocaleString())\n    }\n\n    toString() {\n        return `${this.name}\\t\\t${Math.round(1000 * this.N / (this.duration + 1)).toLocaleString()} ops/sec`\n    }\n\n    toStrings() {\n        return [this.name, `${Math.round(1000 * this.N / (this.duration + 1)).toLocaleString()} ops/sec`]\n    }\n\n    logTable(selector = \"#out\") {\n        tableLogger(selector, [\"Name\", \"Ops/sec\"])(...this.toStrings())\n    }\n}"],"names":["tableLogger","selector","columns","data","row","ensureLogTable","arg","cell","div","existingTable","newTable","headRow","column","BenchSuite","opts","instance","target","methodName","bench","sleep","fn","defaultOpts","B","Benchmark","n","last","prevIters","prevms"],"mappings":"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"}