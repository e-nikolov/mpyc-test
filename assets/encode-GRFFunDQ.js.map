{"version":3,"file":"encode-GRFFunDQ.js","sources":["../../../.yarn/cache/cbor-x-npm-1.5.6-e57ee4fceb-103e75419f.zip/node_modules/cbor-x/decode.js","../../../.yarn/cache/cbor-x-npm-1.5.6-e57ee4fceb-103e75419f.zip/node_modules/cbor-x/encode.js"],"sourcesContent":["let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\treturn key === '__proto__' ? '__proto_' : key\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, null); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n"],"names":["decoder","src","srcEnd","position","LEGACY_RECORD_INLINE_ID","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","PACKED_REFERENCE_TAG_ID","STOP_CODE","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","currentExtensionRanges","packedValues","dataView","restoreMapsAsObject","defaultOptions","sequentialMode","inlineObjectReadThreshold","Decoder","options","k","v","key","rec","map","res","safeKey","source","end","r","saveState","clearSource","error","checkedRead","forEach","values","lastPosition","size","value","defaultDecoder","result","read","token","majorType","getFloat16","multiplier","mult10","array","i","object","readBin","string","shortStringInJS","longStringInJS","readFixedString","structure","createStructureReader","length","readJustLength","id","recordDefinition","readBundleExt","loadShared","extension","input","Tag","packedValue","getPackedValues","validName","readObject","compiledReader","readStringJS","units","byte1","byte2","byte3","byte4","unit","fromCharCode","start","bytes","byte","a","b","c","d","e","f","g","h","j","l","m","n","o","f32Array","u8Array","byte0","exponent","abs","tag","dateString","epochSec","buffer","fraction","existingStructure","data","glbl","packedTable","newPackedValues","target","refEntry","targetProperties","combine","SHARED_DATA_TAG_ID","isLittleEndianMachine","typedArrays","typedArrayTags","registerTypedArray","TypedArray","dvMethod","bytesPerElement","littleEndian","sizeShift","dv","elements","ta","method","bundlePosition","bundleLength","dataPosition","sharedData","updatedStructures","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","textEncoder","extensions","extensionClasses","Buffer","hasNodeBuffer","ByteArrayAllocate","ByteArray","MAX_STRUCTURES","MAX_BUFFER_SIZE","throwOnIterable","targetView","safeEnd","MAX_BUNDLE_SIZE","hasNonLatin","RECORD_SYMBOL","Encoder","sharedStructures","hasSharedUpdate","structures","encodeUtf8","maxBytes","encoder","hasSharedStructures","maxSharedStructures","isSequential","samplingPackedValues","packedObjectMap","sharedValues","sharedPackedObjectMap","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","encodeOptions","REUSE_BUFFER_MODE","sharedStructuresLength","keys","nextTransition","transition","findRepetitiveStrings","writeArrayHeader","valuesArray","encode","THROW_ON_ITERABLE","writeBundles","makeRoom","serialized","insertIds","returnBuffer","RESET_BUFFER_MODE","threshold","status","type","packedPosition","strLength","extStart","twoByte","headerSize","c1","c2","strPosition","useFloat32","xShifted","referee","idsToInsert","constructor","writeObject","entryValue","extensionClass","entry","isBlob","json","vals","safePrototype","objectOffset","newTransitions","parentRecordId","recordId","newSize","newBuffer","chunkThreshold","continuedChunkThreshold","startEncoding","encodeObjectAsIterable","encodeObjectAsAsyncIterable","iterateProperties","finalIterable","useRecords","writeEntityLength","tryEncode","restartEncoding","restart","encodeIterable","encodedValue","reader","next","asyncValue","lastVersion","structuresCopy","SharedData","saveResults","existingShared","majorValue","version","BlobConstructor","packedStatus","includeKeys","date","seconds","set","regex","arrayBuffer","writeBuffer","typedArray","typedArrayEncoder","definitions","offset","nextId","distanceToMove","lastEnd","writeStrings","defaultEncoder"],"mappings":"AAAA,IAAIA,GACJ,GAAI,CACHA,GAAU,IAAI,WACf,MAAe,CAAE,CACjB,IAAIC,EACAC,EACAC,EAAW,EAGf,MAAMC,GAA0B,IAC1BC,GAAwB,MACxBC,GAAmB,MACnBC,GAAqB,MAErBC,GAA0B,EAC1BC,EAAY,CAAE,EAGpB,IAAIC,EAAiB,CAAE,EACnBC,EACAC,GACAC,GAAiB,EACjBC,GAAe,EACfC,EACAC,EACAC,EAAoB,CAAE,EACtBC,GAAyB,CAAE,EAC3BC,EACAC,EACAC,GACAC,GAAiB,CACpB,WAAY,GACZ,cAAe,EAChB,EACIC,GAAiB,GACjBC,GAA4B,EAGhC,GAAI,CACH,IAAI,SAAS,EAAE,CAChB,MAAe,CAEdA,GAA4B,GAC7B,CAIO,MAAMC,EAAQ,CACpB,YAAYC,EAAS,CACpB,GAAIA,KACEA,EAAQ,QAAUA,EAAQ,UAAY,CAACA,EAAQ,aACnDA,EAAQ,WAAa,GACrBA,EAAQ,cAAgB,IAErBA,EAAQ,aAAe,IAASA,EAAQ,gBAAkB,SAC7DA,EAAQ,cAAgB,IACrBA,EAAQ,gBACXA,EAAQ,UAAYA,EAAQ,eACzBA,EAAQ,WAAa,CAACA,EAAQ,cAChCA,EAAQ,WAAa,CAAE,GAAE,cAAgB,IACvCA,EAAQ,QAAQ,CACnB,KAAK,OAAS,IAAI,IAClB,OAAS,CAACC,EAAEC,CAAC,IAAK,OAAO,QAAQF,EAAQ,MAAM,EAAG,KAAK,OAAO,IAAIE,EAAED,CAAC,CACrE,CAEF,OAAO,OAAO,KAAMD,CAAO,CAC3B,CAQD,UAAUG,EAAK,CACd,OAAO,KAAK,QAAS,KAAK,OAAO,IAAIA,CAAG,GAAKA,CAC7C,CAED,UAAUA,EAAK,CACd,OAAO,KAAK,QAAU,KAAK,OAAO,eAAeA,CAAG,EAAI,KAAK,OAAOA,CAAG,EAAIA,CAC3E,CAED,WAAWC,EAAK,CACf,GAAI,CAAC,KAAK,QAAS,OAAOA,EAC1B,IAAIC,EAAM,IAAI,IACd,OAAS,CAACJ,EAAEC,CAAC,IAAK,OAAO,QAAQE,CAAG,EAAGC,EAAI,IAAK,KAAK,QAAQ,eAAeJ,CAAC,EAAI,KAAK,QAAQA,CAAC,EAAIA,EAAIC,CAAC,EACxG,OAAOG,CACP,CAED,WAAWA,EAAK,CACf,GAAI,CAAC,KAAK,SAAWA,EAAI,YAAY,MAAQ,MAAO,OAAOA,EAC3D,GAAI,CAAC,KAAK,QAAS,CAClB,KAAK,QAAU,IAAI,IACnB,OAAS,CAACJ,EAAEC,CAAC,IAAK,OAAO,QAAQ,KAAK,OAAO,EAAG,KAAK,QAAQ,IAAIA,EAAED,CAAC,CACpE,CACD,IAAIK,EAAM,CAAE,EAEZ,OAAAD,EAAI,QAAQ,CAACH,EAAED,IAAMK,EAAIC,EAAQ,KAAK,QAAQ,IAAIN,CAAC,EAAI,KAAK,QAAQ,IAAIA,CAAC,EAAIA,CAAC,CAAC,EAAKC,CAAC,EAC9EI,CACP,CAED,UAAUE,EAAQC,EAAK,CAEtB,IAAIH,EAAM,KAAK,OAAOE,CAAM,EAC5B,GAAI,KAAK,QAER,OAAQF,EAAI,YAAY,KAAI,CAC3B,IAAK,QAAS,OAAOA,EAAI,IAAII,GAAK,KAAK,WAAWA,CAAC,CAAC,CAEpD,CAEF,OAAOJ,CACP,CAED,OAAOE,EAAQC,EAAK,CACnB,GAAIlC,EAEH,OAAOoC,GAAU,KAChBC,GAAa,EACN,KAAO,KAAK,OAAOJ,EAAQC,CAAG,EAAIV,GAAQ,UAAU,OAAO,KAAKH,GAAgBY,EAAQC,CAAG,EAClG,EAEFjC,EAASiC,EAAM,GAAKA,EAAMD,EAAO,OACjC/B,EAAW,EAEXW,GAAe,EACfF,GAAY,KAEZG,EAAiB,KACjBd,EAAMiC,EAIN,GAAI,CACHd,EAAWc,EAAO,WAAaA,EAAO,SAAW,IAAI,SAASA,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EACjH,OAAOK,EAAO,CAGd,MADAtC,EAAM,KACFiC,aAAkB,WACfK,EACD,IAAI,MAAM,oDAAuDL,GAAU,OAAOA,GAAU,SAAYA,EAAO,YAAY,KAAO,OAAOA,EAAO,CACtJ,CACD,GAAI,gBAAgBT,GAAS,CAK5B,GAJAf,EAAiB,KACjBS,EAAe,KAAK,eAClB,KAAK,KAAO,IAAI,MAAM,KAAK,wBAA0B,EAAE,EAAE,OAAO,KAAK,YAAY,EAClF,KAAK,cACF,KAAK,WACR,OAAAR,EAAoB,KAAK,WAClB6B,GAAa,GACV,CAAC7B,GAAqBA,EAAkB,OAAS,KAC3DA,EAAoB,CAAE,EAE1B,MACGD,EAAiBY,IACb,CAACX,GAAqBA,EAAkB,OAAS,KACpDA,EAAoB,CAAE,GACvBQ,EAAe,KAEhB,OAAOqB,GAAa,CACpB,CACD,eAAeN,EAAQO,EAAS,CAC/B,IAAIC,EAAQC,EAAe,EAC3B,GAAI,CACH,IAAIC,EAAOV,EAAO,OAClBX,GAAiB,GACjB,IAAIsB,EAAQ,KAAO,KAAK,OAAOX,EAAQU,CAAI,EAAIE,GAAe,OAAOZ,EAAQU,CAAI,EACjF,GAAIH,EAAS,CACZ,GAAIA,EAAQI,CAAK,IAAM,GACtB,OAED,KAAM1C,EAAWyC,GAEhB,GADAD,EAAexC,EACXsC,EAAQD,IAAa,IAAM,GAC9B,MAGF,KACI,CAEJ,IADAE,EAAS,CAAEG,CAAO,EACZ1C,EAAWyC,GAChBD,EAAexC,EACfuC,EAAO,KAAKF,IAAa,EAE1B,OAAOE,CACP,CACD,OAAOH,EAAO,CACd,MAAAA,EAAM,aAAeI,EACrBJ,EAAM,OAASG,EACTH,CACT,QAAY,CACThB,GAAiB,GACjBe,GAAa,CACb,CACD,CACF,CAIO,SAASE,IAAc,CAC7B,GAAI,CACH,IAAIO,EAASC,EAAM,EACnB,GAAIjC,EAAgB,CACnB,GAAIZ,GAAYY,EAAe,mBAAoB,CAClD,IAAIwB,EAAQ,IAAI,MAAM,4BAA4B,EAClD,MAAAA,EAAM,WAAa,GACbA,CACN,CAEDpC,EAAWY,EAAe,mBAC1BA,EAAiB,IACjB,CAED,GAAIZ,GAAYD,EAEfS,EAAoB,KACpBV,EAAM,KACFe,IACHA,EAAe,cACNb,EAAWD,EAAQ,CAE7B,IAAIqC,EAAQ,IAAI,MAAM,6BAA6B,EACnD,MAAAA,EAAM,WAAa,GACbA,CACT,SAAa,CAAChB,GACX,MAAM,IAAI,MAAM,0CAA0C,EAG3D,OAAOwB,CACP,OAAOR,EAAO,CACd,MAAAD,GAAa,GACTC,aAAiB,YAAcA,EAAM,QAAQ,WAAW,0BAA0B,KACrFA,EAAM,WAAa,IAEdA,CACN,CACF,CAEO,SAASS,GAAO,CACtB,IAAIC,EAAQhD,EAAIE,GAAU,EACtB+C,EAAYD,GAAS,EAEzB,GADAA,EAAQA,EAAQ,GACZA,EAAQ,GACX,OAAQA,EAAK,CACZ,IAAK,IACJA,EAAQhD,EAAIE,GAAU,EACtB,MACD,IAAK,IACJ,GAAI+C,GAAa,EAChB,OAAOC,GAAY,EAEpBF,EAAQ7B,EAAS,UAAUjB,CAAQ,EACnCA,GAAY,EACZ,MACD,IAAK,IACJ,GAAI+C,GAAa,EAAG,CACnB,IAAIL,EAAQzB,EAAS,WAAWjB,CAAQ,EACxC,GAAIO,EAAe,WAAa,EAAG,CAElC,IAAI0C,EAAaC,IAASpD,EAAIE,CAAQ,EAAI,MAAS,EAAMF,EAAIE,EAAW,CAAC,GAAK,CAAE,EAChFA,OAAAA,GAAY,GACHiD,EAAaP,GAASA,EAAQ,EAAI,GAAM,MAAU,GAAKO,CAChE,CACDjD,OAAAA,GAAY,EACL0C,CACP,CACDI,EAAQ7B,EAAS,UAAUjB,CAAQ,EACnCA,GAAY,EACZ,MACD,IAAK,IACJ,GAAI+C,GAAa,EAAG,CACnB,IAAIL,EAAQzB,EAAS,WAAWjB,CAAQ,EACxCA,OAAAA,GAAY,EACL0C,CACP,CACD,GAAIK,EAAY,EAAG,CAClB,GAAI9B,EAAS,UAAUjB,CAAQ,EAAI,EAClC,MAAM,IAAI,MAAM,kFAAkF,EACnG8C,EAAQ7B,EAAS,UAAUjB,EAAW,CAAC,CAC5C,MAAeO,EAAe,eACzBuC,EAAQ7B,EAAS,UAAUjB,CAAQ,EAAI,WACvC8C,GAAS7B,EAAS,UAAUjB,EAAW,CAAC,GAExC8C,EAAQ7B,EAAS,aAAajB,CAAQ,EACvCA,GAAY,EACZ,MACD,IAAK,IAEJ,OAAO+C,EAAS,CACf,IAAK,GACL,IAAK,GACJ,MAAM,IAAI,MAAM,0DAA0D,EAC3E,IAAK,GACJ,IAAII,EAAQ,CAAE,EACVT,EAAOU,EAAI,EACf,MAAQV,EAAQG,EAAM,IAAKvC,GAC1B6C,EAAMC,GAAG,EAAIV,EAEd,OAAOK,GAAa,EAAII,EAAQJ,GAAa,EAAII,EAAM,KAAK,EAAE,EAAI,OAAO,OAAOA,CAAK,EACtF,IAAK,GACJ,IAAIzB,EACJ,GAAInB,EAAe,cAAe,CACjC,IAAI8C,EAAS,CAAE,EACf,GAAI9C,EAAe,OAAQ,MAAOmB,EAAMmB,EAAM,IAAKvC,GAAW+C,EAAOvB,EAAQvB,EAAe,UAAUmB,CAAG,CAAC,CAAC,EAAImB,EAAM,MAChH,OAAQnB,EAAMmB,EAAI,IAAOvC,GAAW+C,EAAOvB,EAAQJ,CAAG,CAAC,EAAImB,EAAM,EACtE,OAAOQ,CACd,KAAa,CACFnC,KACHX,EAAe,cAAgB,GAC/BW,GAAsB,IAEvB,IAAIU,EAAM,IAAI,IACd,GAAIrB,EAAe,OAAQ,MAAOmB,EAAMmB,EAAI,IAAOvC,GAAWsB,EAAI,IAAIrB,EAAe,UAAUmB,CAAG,EAAGmB,EAAI,CAAE,MACtG,OAAQnB,EAAMmB,MAAWvC,GAAWsB,EAAI,IAAIF,EAAKmB,GAAM,EAC5D,OAAOjB,CACP,CACF,IAAK,GACJ,OAAOtB,EACR,QACC,MAAM,IAAI,MAAM,4CAA8CyC,CAAS,CACxE,CACF,QACC,MAAM,IAAI,MAAM,iBAAmBD,CAAK,CACzC,CAEF,OAAQC,EAAS,CAChB,IAAK,GACJ,OAAOD,EACR,IAAK,GACJ,MAAO,CAACA,EACT,IAAK,GACJ,OAAOQ,GAAQR,CAAK,EACrB,IAAK,GACJ,GAAInC,IAAgBX,EACnB,OAAOS,GAAU,MAAMT,EAAWU,IAAiBV,GAAY8C,GAASpC,EAAc,EAEvF,GAAIC,IAAgB,GAAKZ,EAAS,KAAO+C,EAAQ,GAAI,CAEpD,IAAIS,EAAST,EAAQ,GAAKU,GAAgBV,CAAK,EAAIW,GAAeX,CAAK,EACvE,GAAIS,GAAU,KACb,OAAOA,CACR,CACD,OAAOG,GAAgBZ,CAAK,EAC7B,IAAK,GACJ,IAAIK,EAAQ,IAAI,MAAML,CAAK,EAG3B,QAASM,EAAI,EAAGA,EAAIN,EAAOM,IAAKD,EAAMC,CAAC,EAAIP,EAAM,EACjD,OAAOM,EACR,IAAK,GACJ,GAAI5C,EAAe,cAAe,CACjC,IAAI8C,EAAS,CAAE,EACf,GAAI9C,EAAe,OAAQ,QAAS6C,EAAI,EAAGA,EAAIN,EAAOM,IAAKC,EAAOvB,EAAQvB,EAAe,UAAUsC,GAAM,CAAC,CAAC,EAAIA,EAAM,MAChH,SAASO,EAAI,EAAGA,EAAIN,EAAOM,IAAKC,EAAOvB,EAAQe,GAAM,CAAC,EAAIA,EAAM,EACrE,OAAOQ,CACX,KAAU,CACFnC,KACHX,EAAe,cAAgB,GAC/BW,GAAsB,IAEvB,IAAIU,EAAM,IAAI,IACd,GAAIrB,EAAe,OAAQ,QAAS6C,EAAI,EAAGA,EAAIN,EAAOM,IAAKxB,EAAI,IAAIrB,EAAe,UAAUsC,EAAM,CAAA,EAAEA,GAAM,MACrG,SAASO,EAAI,EAAGA,EAAIN,EAAOM,IAAKxB,EAAI,IAAIiB,EAAM,EAAEA,EAAI,CAAE,EAC3D,OAAOjB,CACP,CACF,IAAK,GACJ,GAAIkB,GAAS1C,GAAoB,CAChC,IAAIuD,EAAYnD,EAAkBsC,EAAQ,IAAM,EAEhD,GAAIa,EACH,OAAKA,EAAU,OAAMA,EAAU,KAAOC,GAAsBD,CAAS,GAC9DA,EAAU,KAAM,EAExB,GAAIb,EAAQ,MAAS,CACpB,GAAIA,GAAS3C,GAAkB,CAE9B,IAAI0D,EAASC,GAAgB,EACzBC,EAAKlB,EAAM,EACXc,EAAYd,EAAM,EACtBmB,GAAiBD,EAAIJ,CAAS,EAC9B,IAAIN,EAAS,CAAE,EACf,GAAI9C,EAAe,OAAQ,QAAS6C,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CAC3D,IAAI1B,EAAMnB,EAAe,UAAUoD,EAAUP,EAAI,CAAC,CAAC,EACnDC,EAAOvB,EAAQJ,CAAG,CAAC,EAAImB,EAAM,CAC7B,KACI,SAASO,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CACrC,IAAI1B,EAAMiC,EAAUP,EAAI,CAAC,EACzBC,EAAOvB,EAAQJ,CAAG,CAAC,EAAImB,EAAM,CAC7B,CACD,OAAOQ,CACP,SACQP,GAAS5C,GAAuB,CACxC,IAAI2D,EAASC,GAAgB,EACzBC,EAAKlB,EAAM,EACf,QAASO,EAAI,EAAGA,EAAIS,EAAQT,IAC3BY,GAAiBD,IAAMlB,GAAM,EAE9B,OAAOA,EAAM,CACnB,SAAgBC,GAAS1C,GACnB,OAAO6D,GAAe,EAEvB,GAAI1D,EAAe,YAClB2D,GAAY,EACZP,EAAYnD,EAAkBsC,EAAQ,IAAM,EACxCa,GACH,OAAKA,EAAU,OACdA,EAAU,KAAOC,GAAsBD,CAAS,GAC1CA,EAAU,KAAM,CAGzB,CACD,CACD,IAAIQ,EAAYrD,EAAkBgC,CAAK,EACvC,GAAIqB,EACH,OAAIA,EAAU,YACNA,EAAUtB,CAAI,EAEdsB,EAAUtB,GAAM,EAClB,CACN,IAAIuB,EAAQvB,EAAM,EAClB,QAASO,EAAI,EAAGA,EAAIrC,GAAuB,OAAQqC,IAAK,CACvD,IAAIV,EAAQ3B,GAAuBqC,CAAC,EAAEN,EAAOsB,CAAK,EAClD,GAAI1B,IAAU,OACb,OAAOA,CACR,CACD,OAAO,IAAI2B,EAAID,EAAOtB,CAAK,CAC3B,CACF,IAAK,GACJ,OAAQA,EAAK,CACZ,IAAK,IAAM,MAAO,GAClB,IAAK,IAAM,MAAO,GAClB,IAAK,IAAM,OAAO,KAClB,IAAK,IAAM,OACX,IAAK,IACL,QACC,IAAIwB,GAAetD,GAAgBuD,EAAe,GAAIzB,CAAK,EAC3D,GAAIwB,IAAgB,OACnB,OAAOA,EACR,MAAM,IAAI,MAAM,iBAAmBxB,CAAK,CACzC,CACF,QACC,GAAI,MAAMA,CAAK,EAAG,CACjB,IAAIV,EAAQ,IAAI,MAAM,6BAA6B,EACnD,MAAAA,EAAM,WAAa,GACbA,CACN,CACD,MAAM,IAAI,MAAM,sBAAwBU,CAAK,CAC9C,CACF,CACA,MAAM0B,GAAY,4BAClB,SAASZ,GAAsBD,EAAW,CACzC,SAASc,GAAa,CAErB,IAAIZ,EAAS/D,EAAIE,GAAU,EAG3B,GADA6D,EAASA,EAAS,GACdA,EAAS,GACZ,OAAQA,EAAM,CACb,IAAK,IACJA,EAAS/D,EAAIE,GAAU,EACvB,MACD,IAAK,IACJ6D,EAAS5C,EAAS,UAAUjB,CAAQ,EACpCA,GAAY,EACZ,MACD,IAAK,IACJ6D,EAAS5C,EAAS,UAAUjB,CAAQ,EACpCA,GAAY,EACZ,MACD,QACC,MAAM,IAAI,MAAM,kCAAoCF,EAAIE,EAAW,CAAC,CAAC,CACtE,CAGF,IAAI0E,EAAiB,KAAK,eAC1B,KAAMA,GAAgB,CAErB,GAAIA,EAAe,gBAAkBb,EACpC,OAAOa,EAAe7B,CAAI,EAC3B6B,EAAiBA,EAAe,IAChC,CACD,GAAI,KAAK,aAAerD,GAA2B,CAClD,IAAI8B,EAAQ,KAAK,QAAUU,EAAS,KAAO,KAAK,MAAM,EAAGA,CAAM,EAC/D,OAAAa,EAAiBnE,EAAe,OAC9B,IAAI,SAAS,IAAK,WAAa4C,EAAM,IAAI3B,GAAKjB,EAAe,UAAUiB,CAAC,CAAC,EAAE,IAAIA,GAAKgD,GAAU,KAAKhD,CAAC,EAAIM,EAAQN,CAAC,EAAI,OAAU,IAAM,KAAK,UAAUA,CAAC,EAAI,OAAQ,EAAE,KAAK,GAAG,EAAI,GAAG,EAClL,IAAI,SAAS,IAAK,WAAa2B,EAAM,IAAIzB,GAAO8C,GAAU,KAAK9C,CAAG,EAAII,EAAQJ,CAAG,EAAI,OAAU,IAAM,KAAK,UAAUA,CAAG,EAAI,OAAQ,EAAE,KAAK,GAAG,EAAI,GAAG,EAClJ,KAAK,iBACRgD,EAAe,KAAO,KAAK,gBAC5BA,EAAe,cAAgBb,EAC/B,KAAK,eAAiBa,EACfA,EAAe7B,CAAI,CAC1B,CACD,IAAIQ,EAAS,CAAE,EACf,GAAI9C,EAAe,OAAQ,QAAS6C,EAAI,EAAGA,EAAIS,EAAQT,IAAKC,EAAOvB,EAAQvB,EAAe,UAAU,KAAK6C,CAAC,CAAC,CAAC,CAAC,EAAIP,EAAM,MAClH,SAASO,EAAI,EAAGA,EAAIS,EAAQT,IAChCC,EAAOvB,EAAQ,KAAKsB,CAAC,CAAC,CAAC,EAAIP,IAE5B,OAAOQ,CACP,CACD,OAAAM,EAAU,UAAY,EACfc,CACR,CAEA,SAAS3C,EAAQJ,EAAK,CACrB,OAAOA,IAAQ,YAAc,WAAaA,CAC3C,CAEA,IAAIgC,GAAkBiB,GA4CtB,SAASA,GAAad,EAAQ,CAC7B,IAAIjB,EACJ,GAAIiB,EAAS,KACRjB,EAASY,GAAgBK,CAAM,GAClC,OAAOjB,EAET,GAAIiB,EAAS,IAAMhE,GAClB,OAAOA,GAAQ,OAAOC,EAAI,SAASE,EAAUA,GAAY6D,CAAM,CAAC,EACjE,MAAM7B,EAAMhC,EAAW6D,EACjBe,EAAQ,CAAE,EAEhB,IADAhC,EAAS,GACF5C,EAAWgC,GAAK,CACtB,MAAM6C,EAAQ/E,EAAIE,GAAU,EAC5B,GAAK,EAAA6E,EAAQ,KAEZD,EAAM,KAAKC,CAAK,WACLA,EAAQ,OAAU,IAAM,CAEnC,MAAMC,EAAQhF,EAAIE,GAAU,EAAI,GAChC4E,EAAM,MAAOC,EAAQ,KAAS,EAAKC,CAAK,CACxC,UAAWD,EAAQ,OAAU,IAAM,CAEnC,MAAMC,EAAQhF,EAAIE,GAAU,EAAI,GAC1B+E,EAAQjF,EAAIE,GAAU,EAAI,GAChC4E,EAAM,MAAOC,EAAQ,KAAS,GAAOC,GAAS,EAAKC,CAAK,CACxD,UAAWF,EAAQ,OAAU,IAAM,CAEnC,MAAMC,EAAQhF,EAAIE,GAAU,EAAI,GAC1B+E,EAAQjF,EAAIE,GAAU,EAAI,GAC1BgF,EAAQlF,EAAIE,GAAU,EAAI,GAChC,IAAIiF,GAASJ,EAAQ,IAAS,GAASC,GAAS,GAASC,GAAS,EAAQC,EACtEC,EAAO,QACVA,GAAQ,MACRL,EAAM,KAAOK,IAAS,GAAM,KAAS,KAAM,EAC3CA,EAAO,MAAUA,EAAO,MAEzBL,EAAM,KAAKK,CAAI,CAClB,MACGL,EAAM,KAAKC,CAAK,EAGbD,EAAM,QAAU,OACnBhC,GAAUsC,EAAa,MAAM,OAAQN,CAAK,EAC1CA,EAAM,OAAS,EAEhB,CAED,OAAIA,EAAM,OAAS,IAClBhC,GAAUsC,EAAa,MAAM,OAAQN,CAAK,GAGpChC,CACR,CACA,IAAIsC,EAAe,OAAO,aAC1B,SAASzB,GAAeI,EAAQ,CAC/B,IAAIsB,EAAQnF,EACRoF,EAAQ,IAAI,MAAMvB,CAAM,EAC5B,QAAST,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CAChC,MAAMiC,EAAOvF,EAAIE,GAAU,EAC3B,IAAKqF,EAAO,KAAQ,EAAG,CACtBrF,EAAWmF,EACP,MACA,CACDC,EAAMhC,CAAC,EAAIiC,CACX,CACD,OAAOH,EAAa,MAAM,OAAQE,CAAK,CAC5C,CACA,SAAS5B,GAAgBK,EAAQ,CAChC,GAAIA,EAAS,EACZ,GAAIA,EAAS,EAAG,CACf,GAAIA,IAAW,EACd,MAAO,GACH,CACJ,IAAIyB,EAAIxF,EAAIE,GAAU,EACtB,IAAKsF,EAAI,KAAQ,EAAG,CACnBtF,GAAY,EACZ,MACA,CACD,OAAOkF,EAAaI,CAAC,CACrB,CACJ,KAAS,CACN,IAAIA,EAAIxF,EAAIE,GAAU,EAClBuF,EAAIzF,EAAIE,GAAU,EACtB,IAAKsF,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACrCvF,GAAY,EACZ,MACA,CACD,GAAI6D,EAAS,EACZ,OAAOqB,EAAaI,EAAGC,CAAC,EACzB,IAAIC,EAAI1F,EAAIE,GAAU,EACtB,IAAKwF,EAAI,KAAQ,EAAG,CACnBxF,GAAY,EACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,CAAC,CAC3B,KACK,CACN,IAAIF,EAAIxF,EAAIE,GAAU,EAClBuF,EAAIzF,EAAIE,GAAU,EAClBwF,EAAI1F,EAAIE,GAAU,EAClByF,EAAI3F,EAAIE,GAAU,EACtB,IAAKsF,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACzEzF,GAAY,EACZ,MACA,CACD,GAAI6D,EAAS,EAAG,CACf,GAAIA,IAAW,EACd,OAAOqB,EAAaI,EAAGC,EAAGC,EAAGC,CAAC,EAC1B,CACJ,IAAIC,EAAI5F,EAAIE,GAAU,EACtB,IAAK0F,EAAI,KAAQ,EAAG,CACnB1F,GAAY,EACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CACjC,CACJ,SAAa7B,EAAS,EAAG,CACtB,IAAI6B,EAAI5F,EAAIE,GAAU,EAClB2F,EAAI7F,EAAIE,GAAU,EACtB,IAAK0F,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACrC3F,GAAY,EACZ,MACA,CACD,GAAI6D,EAAS,EACZ,OAAOqB,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,EACrC,IAAIC,EAAI9F,EAAIE,GAAU,EACtB,IAAK4F,EAAI,KAAQ,EAAG,CACnB5F,GAAY,EACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CAC1C,KAAS,CACN,IAAIF,EAAI5F,EAAIE,GAAU,EAClB2F,EAAI7F,EAAIE,GAAU,EAClB4F,EAAI9F,EAAIE,GAAU,EAClB6F,EAAI/F,EAAIE,GAAU,EACtB,IAAK0F,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACzE7F,GAAY,EACZ,MACA,CACD,GAAI6D,EAAS,GAAI,CAChB,GAAIA,IAAW,EACd,OAAOqB,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,EACtC,CACJ,IAAIzC,EAAItD,EAAIE,GAAU,EACtB,IAAKoD,EAAI,KAAQ,EAAG,CACnBpD,GAAY,EACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,CAAC,CAC7C,CACL,SAAcS,EAAS,GAAI,CACvB,IAAIT,EAAItD,EAAIE,GAAU,EAClB8F,EAAIhG,EAAIE,GAAU,EACtB,IAAKoD,EAAI,KAAQ,IAAM0C,EAAI,KAAQ,EAAG,CACrC9F,GAAY,GACZ,MACA,CACD,GAAI6D,EAAS,GACZ,OAAOqB,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,EAAG0C,CAAC,EACjD,IAAItE,EAAI1B,EAAIE,GAAU,EACtB,IAAKwB,EAAI,KAAQ,EAAG,CACnBxB,GAAY,GACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,EAAG0C,EAAGtE,CAAC,CACvD,KAAU,CACN,IAAI4B,EAAItD,EAAIE,GAAU,EAClB8F,EAAIhG,EAAIE,GAAU,EAClBwB,EAAI1B,EAAIE,GAAU,EAClB+F,EAAIjG,EAAIE,GAAU,EACtB,IAAKoD,EAAI,KAAQ,IAAM0C,EAAI,KAAQ,IAAMtE,EAAI,KAAQ,IAAMuE,EAAI,KAAQ,EAAG,CACzE/F,GAAY,GACZ,MACA,CACD,GAAI6D,EAAS,GAAI,CAChB,GAAIA,IAAW,GACd,OAAOqB,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,EAAG0C,EAAGtE,EAAGuE,CAAC,EAClD,CACJ,IAAIC,EAAIlG,EAAIE,GAAU,EACtB,IAAKgG,EAAI,KAAQ,EAAG,CACnBhG,GAAY,GACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,EAAG0C,EAAGtE,EAAGuE,EAAGC,CAAC,CACzD,CACN,KAAW,CACN,IAAIA,EAAIlG,EAAIE,GAAU,EAClBiG,EAAInG,EAAIE,GAAU,EACtB,IAAKgG,EAAI,KAAQ,IAAMC,EAAI,KAAQ,EAAG,CACrCjG,GAAY,GACZ,MACA,CACD,GAAI6D,EAAS,GACZ,OAAOqB,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,EAAG0C,EAAGtE,EAAGuE,EAAGC,EAAGC,CAAC,EAC7D,IAAIC,EAAIpG,EAAIE,GAAU,EACtB,IAAKkG,EAAI,KAAQ,EAAG,CACnBlG,GAAY,GACZ,MACA,CACD,OAAOkF,EAAaI,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGzC,EAAG0C,EAAGtE,EAAGuE,EAAGC,EAAGC,EAAGC,CAAC,CAC/D,CACD,CACD,CACD,CACF,CAEA,SAAS5C,GAAQO,EAAQ,CACxB,OAAOtD,EAAe,YAErB,WAAW,UAAU,MAAM,KAAKT,EAAKE,EAAUA,GAAY6D,CAAM,EACjE/D,EAAI,SAASE,EAAUA,GAAY6D,CAAM,CAC3C,CASA,IAAIsC,GAAW,IAAI,aAAa,CAAC,EAC7BC,GAAU,IAAI,WAAWD,GAAS,OAAQ,EAAG,CAAC,EAClD,SAASnD,IAAa,CACrB,IAAIqD,EAAQvG,EAAIE,GAAU,EACtB6E,EAAQ/E,EAAIE,GAAU,EACtBsG,GAAYD,EAAQ,MAAS,EACjC,GAAIC,IAAa,GAChB,OAAIzB,GAAUwB,EAAQ,EACd,IACAA,EAAQ,IAAQ,KAAY,IAErC,GAAIC,IAAa,EAAG,CAEnB,IAAIC,IAASF,EAAQ,IAAM,EAAKxB,GAAU,SAC1C,OAAQwB,EAAQ,IAAQ,CAACE,EAAMA,CAC/B,CAED,OAAAH,GAAQ,CAAC,EAAKC,EAAQ,KACnBC,GAAY,GAAK,GACpBF,GAAQ,CAAC,GAAMC,EAAQ,IAAM,EAC3BxB,GAAS,EACXuB,GAAQ,CAAC,EAAIvB,GAAS,EACtBuB,GAAQ,CAAC,EAAI,EACND,GAAS,CAAC,CAClB,CAEe,IAAI,MAAM,IAAI,EAgEtB,MAAM9B,CAAI,CAChB,YAAY3B,EAAO8D,EAAK,CACvB,KAAK,MAAQ9D,EACb,KAAK,IAAM8D,CACX,CACF,CAEA1F,EAAkB,CAAC,EAAK2F,GAEhB,IAAI,KAAKA,CAAU,EAG3B3F,EAAkB,CAAC,EAAK4F,GAEhB,IAAI,KAAK,KAAK,MAAMA,EAAW,GAAI,CAAC,EAG5C5F,EAAkB,CAAC,EAAK6F,GAAW,CAElC,IAAIjE,EAAQ,OAAO,CAAC,EACpB,QAASU,EAAI,EAAG2C,EAAIY,EAAO,WAAYvD,EAAI2C,EAAG3C,IAC7CV,EAAQ,OAAOiE,EAAOvD,CAAC,CAAC,EAAIV,GAAS,OAAO,CAAC,EAE9C,OAAOA,CACR,EAEA5B,EAAkB,CAAC,EAAK6F,GAEhB,OAAO,EAAE,EAAI7F,EAAkB,CAAC,EAAE6F,CAAM,EAEhD7F,EAAkB,CAAC,EAAK8F,GAEhB,EAAEA,EAAS,CAAC,EAAI,IAAMA,EAAS,CAAC,GAGxC9F,EAAkB,CAAC,EAAK8F,GAEhBA,EAAS,CAAC,EAAI,KAAK,IAAIA,EAAS,CAAC,EAAI,KAAK,IAAI,CAAC,CAAC,EAIxD,MAAM5C,GAAmB,CAACD,EAAIJ,IAAc,CAC3CI,EAAKA,EAAK,MACV,IAAI8C,EAAoBrG,EAAkBuD,CAAE,EACxC8C,GAAqBA,EAAkB,YACzCrG,EAAkB,oBAAsBA,EAAkB,kBAAoB,KAAKuD,CAAE,EAAI8C,GAE3FrG,EAAkBuD,CAAE,EAAIJ,EAExBA,EAAU,KAAOC,GAAsBD,CAAS,CACjD,EACA7C,EAAkBb,EAAuB,EAAK6G,GAAS,CACtD,IAAIjD,EAASiD,EAAK,OACdnD,EAAYmD,EAAK,CAAC,EACtB9C,GAAiB8C,EAAK,CAAC,EAAGnD,CAAS,EACnC,IAAIN,EAAS,CAAE,EACf,QAASD,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CAChC,IAAI1B,EAAMiC,EAAUP,EAAI,CAAC,EACzBC,EAAOvB,EAAQJ,CAAG,CAAC,EAAIoF,EAAK1D,CAAC,CAC7B,CACD,OAAOC,CACR,EACAvC,EAAkB,EAAE,EAAK4B,GACpB9B,EACIA,EAAe,CAAC,EAAE,MAAMA,EAAe,UAAWA,EAAe,WAAa8B,CAAK,EACpF,IAAI2B,EAAI3B,EAAO,EAAE,EAEzB5B,EAAkB,EAAE,EAAK4B,GACpB9B,EACIA,EAAe,CAAC,EAAE,MAAMA,EAAe,UAAWA,EAAe,WAAa8B,CAAK,EACpF,IAAI2B,EAAI3B,EAAO,EAAE,EAEzB,IAAIqE,GAAO,CAAE,MAAO,MAAQ,EAC5BjG,EAAkB,EAAE,EAAKgG,IAChBC,GAAKD,EAAK,CAAC,CAAC,GAAK,OAAOA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EAEjD,MAAME,GAAenE,GAAS,CAC7B,GAAI/C,EAAIE,GAAU,GAAK,IAAM,CAC5B,IAAIoC,EAAQ,IAAI,MAAM,+DAA+D,EACrF,MAAItC,EAAI,OAASE,IAChBoC,EAAM,WAAa,IACdA,CACN,CACD,IAAI6E,EAAkBpE,EAAM,EAC5B,GAAI,CAACoE,GAAmB,CAACA,EAAgB,OAAQ,CAChD,IAAI7E,EAAQ,IAAI,MAAM,+DAA+D,EACrF,MAAAA,EAAM,WAAa,GACbA,CACN,CACD,OAAApB,EAAeA,EAAeiG,EAAgB,OAAOjG,EAAa,MAAMiG,EAAgB,MAAM,CAAC,EAAIA,EACnGjG,EAAa,SAAW6B,EAAM,EAC9B7B,EAAa,SAAW6B,EAAM,EACvBA,EAAM,CACd,EACAmE,GAAY,YAAc,GAC1BlG,EAAkB,EAAE,EAAIkG,GAExBlG,EAAkBT,EAAuB,EAAKyG,GAAS,CACtD,GAAI,CAAC9F,EACJ,GAAIT,EAAe,UAClB2D,GAAY,MAEZ,QAAO,IAAIG,EAAIyC,EAAMzG,EAAuB,EAE9C,GAAI,OAAOyG,GAAQ,SAClB,OAAO9F,EAAa,IAAM8F,GAAQ,EAAI,EAAIA,EAAQ,GAAKA,EAAO,EAAG,EAClE,IAAI1E,EAAQ,IAAI,MAAM,kDAAkD,EACxE,MAAI0E,IAAS,SACZ1E,EAAM,WAAa,IACdA,CACP,EAmBAtB,EAAkB,EAAE,EAAK+B,GAAS,CAE5BhC,IACJA,EAAe,IAAI,IACnBA,EAAa,GAAK,GAEnB,IAAIkD,EAAKlD,EAAa,KAClBiC,EAAQhD,EAAIE,CAAQ,EACpBkH,EAGCpE,GAAS,GAAM,EACnBoE,EAAS,CAAE,EAEXA,EAAS,CAAE,EAEZ,IAAIC,EAAW,CAAE,OAAAD,CAAQ,EACzBrG,EAAa,IAAIkD,EAAIoD,CAAQ,EAC7B,IAAIC,EAAmBvE,EAAM,EAC7B,OAAIsE,EAAS,KACL,OAAO,OAAOD,EAAQE,CAAgB,GAC9CD,EAAS,OAASC,EACXA,EACR,EACAtG,EAAkB,EAAE,EAAE,YAAc,GAEpCA,EAAkB,EAAE,EAAKiD,GAAO,CAE/B,IAAIoD,EAAWtG,EAAa,IAAIkD,CAAE,EAClC,OAAAoD,EAAS,KAAO,GACTA,EAAS,MACjB,EAEArG,EAAkB,GAAG,EAAKqC,GAAU,IAAI,IAAIA,CAAK,GAChDrC,EAAkB,GAAG,EAAK+B,IAGtBtC,EAAe,gBAClBA,EAAe,cAAgB,GAC/BW,GAAsB,IAEhB2B,EAAM,IACX,YAAc,GACjB,SAASwE,GAAQ/B,EAAGC,EAAG,CACtB,OAAI,OAAOD,GAAM,SACTA,EAAIC,EACRD,aAAa,MACTA,EAAE,OAAOC,CAAC,EACX,OAAO,OAAO,GAAID,EAAGC,CAAC,CAC9B,CACA,SAAShB,GAAkB,CAC1B,GAAI,CAACvD,EACJ,GAAIT,EAAe,UAClB2D,GAAY,MAEZ,OAAM,IAAI,MAAM,4BAA4B,EAE9C,OAAOlD,CACR,CACA,MAAMsG,GAAqB,WAC3BvG,GAAuB,KAAK,CAACyF,EAAKpC,IAAU,CAC3C,GAAIoC,GAAO,KAAOA,GAAO,IACxB,OAAOa,GAAQ9C,IAAkB,SAASiC,EAAM,GAAG,EAAGpC,CAAK,EAC5D,GAAIoC,GAAO,OAASA,GAAO,MAC1B,OAAOa,GAAQ9C,IAAkB,SAASiC,EAAM,KAAK,EAAGpC,CAAK,EAC9D,GAAIoC,GAAO,YAAcA,GAAO,WAC/B,OAAOa,GAAQ9C,IAAkB,SAASiC,EAAM,UAAU,EAAGpC,CAAK,EACnE,GAAIoC,GAAO,KAAOA,GAAO,IACxB,OAAOa,GAAQjD,EAAOG,EAAe,EAAG,SAASiC,EAAM,GAAG,CAAC,EAC5D,GAAIA,GAAO,OAASA,GAAO,MAC1B,OAAOa,GAAQjD,EAAOG,EAAe,EAAG,SAASiC,EAAM,KAAK,CAAC,EAC9D,GAAIA,GAAO,YAAcA,GAAO,WAC/B,OAAOa,GAAQjD,EAAOG,EAAe,EAAG,SAASiC,EAAM,UAAU,CAAC,EACnE,GAAIA,GAAOc,GACV,MAAO,CACN,aAActG,EACd,WAAYR,EAAkB,MAAM,CAAC,EACrC,QAAS4D,CACT,EAEF,GAAIoC,GAAO,MACV,OAAOpC,CACT,CAAC,EAED,MAAMmD,GAAwB,IAAI,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,GAAK,EACnEC,GAAc,CAAC,WAAY,kBAAmB,YAAa,YACvE,OAAO,eAAkB,IAAc,CAAE,KAAK,gBAAgB,EAAK,eAAgB,UAAW,WAAY,WAC1G,OAAO,cAAiB,IAAc,CAAE,KAAK,eAAe,EAAK,cAAe,aAAc,YAAY,EACrGC,GAAiB,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,EAClE,QAASrE,EAAI,EAAGA,EAAIoE,GAAY,OAAQpE,IACvCsE,GAAmBF,GAAYpE,CAAC,EAAGqE,GAAerE,CAAC,CAAC,EAErD,SAASsE,GAAmBC,EAAYnB,EAAK,CAC5C,IAAIoB,EAAW,MAAQD,EAAW,KAAK,MAAM,EAAG,EAAE,EAC9CE,EACA,OAAOF,GAAe,WACzBE,EAAkBF,EAAW,kBAE7BA,EAAa,KACd,QAASG,EAAe,EAAGA,EAAe,EAAGA,IAAgB,CAC5D,GAAI,CAACA,GAAgBD,GAAmB,EACvC,SACD,IAAIE,EAAYF,GAAmB,EAAI,EAAIA,GAAmB,EAAI,EAAI,EACtE/G,EAAkBgH,EAAetB,EAAOA,EAAM,CAAE,EAAKqB,GAAmB,GAAKC,GAAgBP,GAA0BZ,GAAW,CACjI,GAAI,CAACgB,EACJ,MAAM,IAAI,MAAM,uCAAyCnB,CAAG,EAC7D,MAAI,CAACjG,EAAe,cAEfsH,IAAoB,GACvBA,IAAoB,GAAK,EAAElB,EAAO,WAAa,IAC/CkB,IAAoB,GAAK,EAAElB,EAAO,WAAa,IAC/CkB,IAAoB,GAAK,EAAElB,EAAO,WAAa,IACxC,IAAIgB,EAAWhB,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAGpE,IAAIgB,EAAW,WAAW,UAAU,MAAM,KAAKhB,EAAQ,CAAC,EAAE,MAAM,CACvE,EAAGA,GAAU,CACb,GAAI,CAACgB,EACJ,MAAM,IAAI,MAAM,uCAAyCnB,CAAG,EAC7D,IAAIwB,EAAK,IAAI,SAASrB,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EACrEsB,EAAWtB,EAAO,QAAUoB,EAC5BG,EAAK,IAAIP,EAAWM,CAAQ,EAC5BE,EAASH,EAAGJ,CAAQ,EACxB,QAASxE,EAAI,EAAGA,EAAI6E,EAAU7E,IAC7B8E,EAAG9E,CAAC,EAAI+E,EAAO,KAAKH,EAAI5E,GAAK2E,EAAWD,CAAY,EAErD,OAAOI,CACP,CACD,CACF,CAEA,SAASjE,IAAgB,CACxB,IAAIJ,EAASC,GAAgB,EACzBsE,EAAiBpI,EAAW6C,EAAM,EACtC,QAASO,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CAEhC,IAAIiF,EAAevE,GAAgB,EACnC9D,GAAYqI,CACZ,CACD,IAAIC,EAAetI,EACnBA,OAAAA,EAAWoI,EACXxH,EAAiB,CAAC+D,GAAab,GAAc,CAAE,EAAGa,GAAab,GAAc,CAAE,CAAC,EAChFlD,EAAe,UAAY,EAC3BA,EAAe,UAAY,EAC3BA,EAAe,mBAAqBZ,EACpCA,EAAWsI,EACJzF,EAAM,CACd,CAEA,SAASiB,IAAiB,CACzB,IAAIhB,EAAQhD,EAAIE,GAAU,EAAI,GAC9B,GAAI8C,EAAQ,GACX,OAAQA,EAAK,CACZ,IAAK,IACJA,EAAQhD,EAAIE,GAAU,EACtB,MACD,IAAK,IACJ8C,EAAQ7B,EAAS,UAAUjB,CAAQ,EACnCA,GAAY,EACZ,MACD,IAAK,IACJ8C,EAAQ7B,EAAS,UAAUjB,CAAQ,EACnCA,GAAY,EACZ,KACD,CAEF,OAAO8C,CACR,CAEA,SAASoB,IAAa,CACrB,GAAI3D,EAAe,UAAW,CAC7B,IAAIgI,EAAarG,GAAU,KAE1BpC,EAAM,KACCS,EAAe,UAAW,EACjC,GAAK,CAAE,EACJiI,EAAoBD,EAAW,YAAc,CAAE,EACnDhI,EAAe,cAAgBgI,EAAW,QAC1CvH,EAAeT,EAAe,aAAegI,EAAW,aACpD/H,IAAsB,GACzBD,EAAe,WAAaC,EAAoBgI,EAEhDhI,EAAkB,OAAO,MAAMA,EAAmB,CAAC,EAAGgI,EAAkB,MAAM,EAAE,OAAOA,CAAiB,CAAC,CAC1G,CACF,CAEA,SAAStG,GAAUuG,EAAU,CAC5B,IAAIC,EAAc3I,EACd4I,EAAgB3I,EAEhB4I,EAAsBlI,GACtBmI,EAAoBlI,GACpBmI,EAAiBrI,GAEjBsI,EAAoBlI,EACpBmI,EAAsBpI,EAGtBqI,EAAW,IAAI,WAAWnJ,EAAI,MAAM,EAAGC,CAAM,CAAC,EAC9CmJ,EAAkB1I,EAClB2I,EAAe5I,EACf6I,EAAsBhI,GACtBsB,EAAQ+F,EAAU,EACtB,OAAA1I,EAAS2I,EACT1I,EAAW2I,EAEXjI,GAAiBkI,EACjBjI,GAAekI,EACfpI,GAAYqI,EAEZjI,EAAekI,EACfnI,EAAiBoI,EACjBlJ,EAAMmJ,EACN7H,GAAiBgI,EACjB5I,EAAoB0I,EACpB3I,EAAiB4I,EACjBlI,EAAW,IAAI,SAASnB,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC3D4C,CACR,CACO,SAASP,IAAc,CAC7BrC,EAAM,KACNe,EAAe,KACfL,EAAoB,IACrB,CAMO,MAAM0C,GAAS,IAAI,MAAM,GAAG,EACnC,QAASE,EAAI,EAAGA,EAAI,IAAKA,IACxBF,GAAOE,CAAC,EAAI,EAAE,KAAO,KAAK,MAAM,MAAQA,EAAI,MAAO,GAEpD,IAAIT,GAAiB,IAAIrB,GAAQ,CAAE,WAAY,EAAK,CAAE,EAChCqB,GAAe,OACPA,GAAe,eCzsC7C,IAAI0G,GACJ,GAAI,CACHA,GAAc,IAAI,WACnB,MAAgB,CAAE,CAClB,IAAIC,GAAYC,GAChB,MAAMC,GAAS,OAAO,YAAe,UAAY,WAAW,OACtDC,GAAgB,OAAOD,GAAW,IAClCE,GAAoBD,GAAgBD,GAAO,gBAAkB,WAC7DG,GAAYF,GAAgBD,GAAS,WACrCI,GAAiB,IACjBC,GAAkBJ,GAAgB,WAAc,WAEtD,IAAIK,GACA5C,EACA6C,EACA/J,EAAW,EACXgK,EACApJ,EAAiB,KACrB,MAAMqJ,GAAkB,MAClBC,GAAc,kBACdC,EAAgB,OAAO,WAAW,EACjC,MAAMC,WAAgB9I,EAAQ,CACpC,YAAYC,EAAS,CACpB,MAAMA,CAAO,EACb,KAAK,OAAS,EAEd,IAAI4D,EACAkF,EACAC,EACAC,EACA1J,EACJU,EAAUA,GAAW,CAAE,EACvB,IAAIiJ,EAAab,GAAU,UAAU,UAAY,SAASpG,EAAQvD,EAAUyK,EAAU,CACrF,OAAOvD,EAAO,UAAU3D,EAAQvD,EAAUyK,CAAQ,CACrD,EAAOpB,IAAeA,GAAY,WAC/B,SAAS9F,EAAQvD,EAAU,CAC1B,OAAOqJ,GAAY,WAAW9F,EAAQ2D,EAAO,SAASlH,CAAQ,CAAC,EAAE,OACrE,EAAO,GAED0K,EAAU,KACVC,EAAsBpJ,EAAQ,YAAcA,EAAQ,eACpDqJ,EAAsBrJ,EAAQ,oBAGlC,GAFIqJ,GAAuB,OAC1BA,EAAsBD,EAAsB,IAAM,GAC/CC,EAAsB,KACzB,MAAM,IAAI,MAAM,oCAAoC,EACrD,IAAIC,EAAetJ,EAAQ,WACvBsJ,IACHD,EAAsB,GAElB,KAAK,aACT,KAAK,WAAa,CAAE,GACjB,KAAK,iBACR,KAAK,WAAa,KAAK,gBACxB,IAAIE,EAAsBC,EAAiBC,EAAezJ,EAAQ,aAC9D0J,EACJ,GAAID,EAAc,CACjBC,EAAwB,OAAO,OAAO,IAAI,EAC1C,QAAS7H,EAAI,EAAG2C,EAAIiF,EAAa,OAAQ5H,EAAI2C,EAAG3C,IAC/C6H,EAAsBD,EAAa5H,CAAC,CAAC,EAAIA,CAE1C,CACD,IAAI8H,EAAoB,CAAE,EACtBC,GAAmB,EACnBC,GAAuC,EAE3C,KAAK,UAAY,SAAS1I,EAAO2I,EAAe,CAE/C,GAAI,KAAK,SAAW,CAAC,KAAK,QAEzB,OAAQ3I,EAAM,YAAY,KAAI,CAC7B,IAAK,QACJA,EAAQA,EAAM,IAAIT,GAAK,KAAK,WAAWA,CAAC,CAAC,EACzC,KAID,CAGF,OAAO,KAAK,OAAOS,EAAO2I,CAAa,CACvC,EAED,KAAK,OAAS,SAAS3I,EAAO2I,EAAe,CA4B5C,GA3BKnE,IACJA,EAAS,IAAIwC,GAAkB,IAAI,EACnCK,EAAa,IAAI,SAAS7C,EAAO,OAAQ,EAAG,IAAI,EAChDlH,EAAW,GAEZgK,EAAU9C,EAAO,OAAS,GACtB8C,EAAUhK,EAAW,MAExBkH,EAAS,IAAIwC,GAAkBxC,EAAO,MAAM,EAC5C6C,EAAa,IAAI,SAAS7C,EAAO,OAAQ,EAAGA,EAAO,MAAM,EACzD8C,EAAU9C,EAAO,OAAS,GAC1BlH,EAAW,GACDqL,IAAkBC,KAC5BtL,EAAYA,EAAW,EAAK,YAC7BmF,EAAQnF,EACJ0K,EAAQ,yBACXX,EAAW,UAAU/J,EAAU,UAAU,EACzCA,GAAY,GAEba,EAAe6J,EAAQ,gBAAkB,IAAI,IAAQ,KACjDA,EAAQ,eAAiB,OAAOhI,GAAU,UAC7C9B,EAAiB,CAAE,EACnBA,EAAe,KAAO,KAEtBA,EAAiB,KAElByJ,EAAmBK,EAAQ,WACvBL,EAAkB,CACrB,GAAIA,EAAiB,cAAe,CACnC,IAAI9B,EAAamC,EAAQ,UAAS,GAAM,CAAE,EAC1CA,EAAQ,WAAaL,EAAmB9B,EAAW,YAAc,CAAE,EACnEmC,EAAQ,cAAgBnC,EAAW,QACnC,IAAIyC,EAAeN,EAAQ,aAAenC,EAAW,aACrD,GAAIyC,EAAc,CACjBC,EAAwB,CAAE,EAC1B,QAAS7H,EAAI,EAAG2C,EAAIiF,EAAa,OAAQ5H,EAAI2C,EAAG3C,IAC/C6H,EAAsBD,EAAa5H,CAAC,CAAC,EAAIA,CAC1C,CACD,CACD,IAAImI,EAAyBlB,EAAiB,OAG9C,GAFIkB,EAAyBX,GAAuB,CAACC,IACpDU,EAAyBX,GACtB,CAACP,EAAiB,YAAa,CAElCA,EAAiB,YAAc,OAAO,OAAO,IAAI,EACjD,QAASjH,EAAI,EAAGA,EAAImI,EAAwBnI,IAAK,CAChD,IAAIoI,EAAOnB,EAAiBjH,CAAC,EAE7B,GAAI,CAACoI,EACJ,SACD,IAAIC,EAAgBC,EAAarB,EAAiB,YAClD,QAASvE,EAAI,EAAGC,EAAIyF,EAAK,OAAQ1F,EAAIC,EAAGD,IAAK,CACxC4F,EAAWvB,CAAa,IAAM,SACjCuB,EAAWvB,CAAa,EAAI/G,GAC7B,IAAI1B,EAAM8J,EAAK1F,CAAC,EAChB2F,EAAiBC,EAAWhK,CAAG,EAC1B+J,IACJA,EAAiBC,EAAWhK,CAAG,EAAI,OAAO,OAAO,IAAI,GAEtDgK,EAAaD,CACb,CACDC,EAAWvB,CAAa,EAAI/G,EAAI,OAChC,CACD,CACIyH,IACJR,EAAiB,OAASkB,EAC3B,CAKD,GAJIjB,IACHA,EAAkB,IACnBC,EAAaF,GAAoB,CAAE,EACnCU,EAAkBE,EACd1J,EAAQ,KAAM,CACjB,IAAIP,EAAe,IAAI,IAOvB,GANAA,EAAa,OAAS,CAAE,EACxBA,EAAa,QAAU0J,EACvB1J,EAAa,UAAYO,EAAQ,yBAA2B0J,EAAwB,GAAK,KACzFjK,EAAa,UAAYiK,GAAyB,GAClDjK,EAAa,qBAAuB8J,EACpCa,GAAsBjJ,EAAO1B,CAAY,EACrCA,EAAa,OAAO,OAAS,EAAG,CACnCkG,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI,GACrB4L,EAAiB,CAAC,EAClB,IAAIC,EAAc7K,EAAa,OAC/B8K,EAAOD,CAAW,EAClBD,EAAiB,CAAC,EAClBA,EAAiB,CAAC,EAClBb,EAAkB,OAAO,OAAOE,GAAyB,IAAI,EAC7D,QAAS7H,EAAI,EAAG2C,EAAI8F,EAAY,OAAQzI,EAAI2C,EAAG3C,IAC9C2H,EAAgBc,EAAYzI,CAAC,CAAC,EAAIA,CAEnC,CACD,CACD0G,GAAkBuB,EAAgBU,GAClC,GAAI,CACH,GAAIjC,GACH,OAMD,GALAgC,EAAOpJ,CAAK,EACR9B,GACHoL,GAAa7G,EAAO2G,CAAM,EAE3BpB,EAAQ,OAAS1K,EACba,GAAgBA,EAAa,YAAa,CAC7Cb,GAAYa,EAAa,YAAY,OAAS,EAC1Cb,EAAWgK,GACdiC,GAASjM,CAAQ,EAClB0K,EAAQ,OAAS1K,EACjB,IAAIkM,EAAaC,GAAUjF,EAAO,SAAS/B,EAAOnF,CAAQ,EAAGa,EAAa,WAAW,EACrF,OAAAA,EAAe,KACRqL,CACP,CACD,OAAIb,EAAgBC,IACnBpE,EAAO,MAAQ/B,EACf+B,EAAO,IAAMlH,EACNkH,GAEDA,EAAO,SAAS/B,EAAOnF,CAAQ,CAC1C,QAAa,CACT,GAAIqK,GAKH,GAJIe,GAAuC,IAC1CA,KACGf,EAAiB,OAASO,IAC7BP,EAAiB,OAASO,GACvBO,GAAmB,IAEtBd,EAAiB,YAAc,KAC/Be,GAAuC,EACvCD,GAAmB,EACfD,EAAkB,OAAS,IAC9BA,EAAoB,CAAE,WACbA,EAAkB,OAAS,GAAK,CAACL,EAAc,CACzD,QAASzH,EAAI,EAAG2C,EAAImF,EAAkB,OAAQ9H,EAAI2C,EAAG3C,IACpD8H,EAAkB9H,CAAC,EAAE+G,CAAa,EAAI,OAEvCe,EAAoB,CAAE,CAEtB,EAEF,GAAIZ,GAAmBI,EAAQ,WAAY,CACtCA,EAAQ,WAAW,OAASE,IAC/BF,EAAQ,WAAaA,EAAQ,WAAW,MAAM,EAAGE,CAAmB,GAGrE,IAAIwB,EAAelF,EAAO,SAAS/B,EAAOnF,CAAQ,EAClD,OAAI0K,EAAQ,iBAAgB,IAAO,GAC3BA,EAAQ,OAAOhI,CAAK,EACrB0J,CACP,CACGf,EAAgBgB,KACnBrM,EAAWmF,EACZ,CACD,EACD,KAAK,wBAA0B,KAC9B2F,EAAuB,IAAI,IACtBG,IACJA,EAAwB,OAAO,OAAO,IAAI,GACnC1J,GAAY,CACnB,IAAI+K,EAAY/K,GAAWA,EAAQ,WAAa,EAC5CvB,EAAW,KAAK,KAAOuB,EAAQ,wBAA0B,GAAK,EAC7DyJ,IACJA,EAAe,KAAK,aAAe,CAAE,GACtC,OAAS,CAAEtJ,EAAK6K,CAAM,IAAMzB,EACvByB,EAAO,MAAQD,IAClBrB,EAAsBvJ,CAAG,EAAI1B,IAC7BgL,EAAa,KAAKtJ,CAAG,EACrB4I,EAAkB,IAGpB,KAAO,KAAK,YAAc,KAAK,iBAAkB,IAAK,IAAO,CAC7DQ,EAAuB,IACvB,GAEF,MAAMgB,EAAUpJ,GAAU,CACrB1C,EAAWgK,IACd9C,EAAS+E,GAASjM,CAAQ,GAE3B,IAAIwM,EAAO,OAAO9J,EACdmB,EACJ,GAAI2I,IAAS,SAAU,CACtB,GAAIzB,EAAiB,CACpB,IAAI0B,EAAiB1B,EAAgBrI,CAAK,EAC1C,GAAI+J,GAAkB,EAAG,CACpBA,EAAiB,GACpBvF,EAAOlH,GAAU,EAAIyM,EAAiB,KAEtCvF,EAAOlH,GAAU,EAAI,IACjByM,EAAiB,EACpBX,EAAQ,GAAKW,GAAmB,CAAC,EAEjCX,EAAQW,EAAiB,IAAO,CAAC,GAEnC,MAeA,SAAU3B,GAAwB,CAACvJ,EAAQ,KAAM,CACjD,IAAIgL,EAASzB,EAAqB,IAAIpI,CAAK,EACvC6J,EACHA,EAAO,QAEPzB,EAAqB,IAAIpI,EAAO,CAC/B,MAAO,CACf,CAAQ,CACF,CACD,CACD,IAAIgK,EAAYhK,EAAM,OACtB,GAAI9B,GAAkB8L,GAAa,GAAKA,EAAY,KAAO,CAC1D,IAAK9L,EAAe,MAAQ8L,GAAazC,GAAiB,CACzD,IAAI0C,EACAlC,GAAY7J,EAAe,CAAC,EAAIA,EAAe,CAAC,EAAE,OAAS,EAAIA,EAAe,CAAC,EAAE,OAAS,GAAK,GAC/FZ,EAAWyK,EAAWT,IACzB9C,EAAS+E,GAASjM,EAAWyK,CAAQ,GACtCvD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI,IAErBkH,EAAOlH,GAAU,EAAIY,EAAe,SAAW,IAAO,IACtDsG,EAAOlH,GAAU,EAAI,GACrB2M,EAAW3M,EAAWmF,EACtBnF,GAAY,EACRY,EAAe,UAClBoL,GAAa7G,EAAO2G,CAAM,EAE3BlL,EAAiB,CAAC,GAAI,EAAE,EACxBA,EAAe,KAAO,EACtBA,EAAe,SAAW+L,CAC1B,CACD,IAAIC,EAAU1C,GAAY,KAAKxH,CAAK,EACpC9B,EAAegM,EAAU,EAAI,CAAC,GAAKlK,EACnCwE,EAAOlH,GAAU,EAAI4M,EAAU,IAAO,IACtCd,EAAOY,CAAS,EAChB,MACA,CACD,IAAIG,EAEAH,EAAY,GACfG,EAAa,EACHH,EAAY,IACtBG,EAAa,EACHH,EAAY,MACtBG,EAAa,EAEbA,EAAa,EAEd,IAAIpC,EAAWiC,EAAY,EAI3B,GAHI1M,EAAWyK,EAAWT,IACzB9C,EAAS+E,GAASjM,EAAWyK,CAAQ,GAElCiC,EAAY,IAAQ,CAAClC,EAAY,CACpC,IAAIpH,EAAG0J,EAAIC,EAAIC,EAAchN,EAAW6M,EACxC,IAAKzJ,EAAI,EAAGA,EAAIsJ,EAAWtJ,IAC1B0J,EAAKpK,EAAM,WAAWU,CAAC,EACnB0J,EAAK,IACR5F,EAAO8F,GAAa,EAAIF,EACdA,EAAK,MACf5F,EAAO8F,GAAa,EAAIF,GAAM,EAAI,IAClC5F,EAAO8F,GAAa,EAAIF,EAAK,GAAO,MAEnCA,EAAK,SAAY,SAChBC,EAAKrK,EAAM,WAAWU,EAAI,CAAC,GAAK,SAAY,OAE9C0J,EAAK,QAAYA,EAAK,OAAW,KAAOC,EAAK,MAC7C3J,IACA8D,EAAO8F,GAAa,EAAIF,GAAM,GAAK,IACnC5F,EAAO8F,GAAa,EAAIF,GAAM,GAAK,GAAO,IAC1C5F,EAAO8F,GAAa,EAAIF,GAAM,EAAI,GAAO,IACzC5F,EAAO8F,GAAa,EAAIF,EAAK,GAAO,MAEpC5F,EAAO8F,GAAa,EAAIF,GAAM,GAAK,IACnC5F,EAAO8F,GAAa,EAAIF,GAAM,EAAI,GAAO,IACzC5F,EAAO8F,GAAa,EAAIF,EAAK,GAAO,KAGtCjJ,EAASmJ,EAAchN,EAAW6M,CACvC,MACKhJ,EAAS2G,EAAW9H,EAAO1C,EAAW6M,EAAYpC,CAAQ,EAGvD5G,EAAS,GACZqD,EAAOlH,GAAU,EAAI,GAAO6D,EAClBA,EAAS,KACfgJ,EAAa,GAChB3F,EAAO,WAAWlH,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAI6D,CAAM,EAEpEqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GACXA,EAAS,OACfgJ,EAAa,GAChB3F,EAAO,WAAWlH,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAI6D,CAAM,EAEpEqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GAAU,EAC/BqD,EAAOlH,GAAU,EAAI6D,EAAS,MAE1BgJ,EAAa,GAChB3F,EAAO,WAAWlH,EAAW,EAAGA,EAAW,EAAGA,EAAW,EAAI6D,CAAM,EAEpEqD,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,UAAU/J,EAAU6D,CAAM,EACrC7D,GAAY,GAEbA,GAAY6D,CAChB,SAAc2I,IAAS,SACnB,GAAI,CAAC,KAAK,gBAAkB9J,IAAU,IAAMA,EAEvCA,EAAQ,GACXwE,EAAOlH,GAAU,EAAI0C,EACXA,EAAQ,KAClBwE,EAAOlH,GAAU,EAAI,GACrBkH,EAAOlH,GAAU,EAAI0C,GACXA,EAAQ,OAClBwE,EAAOlH,GAAU,EAAI,GACrBkH,EAAOlH,GAAU,EAAI0C,GAAS,EAC9BwE,EAAOlH,GAAU,EAAI0C,EAAQ,MAE7BwE,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,UAAU/J,EAAU0C,CAAK,EACpC1C,GAAY,WAEH,CAAC,KAAK,gBAAkB0C,GAAS,IAAMA,EAC7CA,GAAS,IACZwE,EAAOlH,GAAU,EAAI,GAAO0C,EAClBA,GAAS,MACnBwE,EAAOlH,GAAU,EAAI,GACrBkH,EAAOlH,GAAU,EAAI,CAAC0C,GACZA,GAAS,QACnBwE,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,UAAU/J,EAAU,CAAC0C,CAAK,EACrC1C,GAAY,IAEZkH,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,UAAU/J,EAAU,CAAC0C,CAAK,EACrC1C,GAAY,OAEP,CACN,IAAIiN,EACJ,IAAKA,EAAa,KAAK,YAAc,GAAKvK,EAAQ,YAAeA,GAAS,YAAa,CACtFwE,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,WAAW/J,EAAU0C,CAAK,EACrC,IAAIwK,EACJ,GAAID,EAAa,IAEbC,EAAWxK,EAAQQ,IAASgE,EAAOlH,CAAQ,EAAI,MAAS,EAAMkH,EAAOlH,EAAW,CAAC,GAAK,CAAE,IAAM,IAAOkN,EAAU,CAClHlN,GAAY,EACZ,MACA,MACAA,GACD,CACDkH,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,WAAW/J,EAAU0C,CAAK,EACrC1C,GAAY,CACZ,SACSwM,IAAS,SACnB,GAAI,CAAC9J,EACJwE,EAAOlH,GAAU,EAAI,QACjB,CACJ,GAAIa,EAAc,CACjB,IAAIsM,EAAUtM,EAAa,IAAI6B,CAAK,EACpC,GAAIyK,EAAS,CAIZ,GAHAjG,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI,GACrBkH,EAAOlH,GAAU,EAAI,GACjB,CAACmN,EAAQ,WAAY,CACxB,IAAIC,EAAcvM,EAAa,cAAgBA,EAAa,YAAc,CAAA,GAC1EsM,EAAQ,WAAa,CAAE,EACvBC,EAAY,KAAKD,CAAO,CACxB,CACDA,EAAQ,WAAW,KAAKnN,EAAWmF,CAAK,EACxCnF,GAAY,EACZ,MACA,MACAa,EAAa,IAAI6B,EAAO,CAAE,OAAQ1C,EAAWmF,EAAO,CACrD,CACD,IAAIkI,EAAc3K,EAAM,YACxB,GAAI2K,IAAgB,OACnBC,GAAY5K,EAAO,EAAI,UACb2K,IAAgB,MAAO,CACjCxJ,EAASnB,EAAM,OACXmB,EAAS,GACZqD,EAAOlH,GAAU,EAAI,IAAO6D,EAE5B+H,EAAiB/H,CAAM,EAExB,QAAST,EAAI,EAAGA,EAAIS,EAAQT,IAC3B0I,EAAOpJ,EAAMU,CAAC,CAAC,CAEtB,SAAgBiK,IAAgB,IAsB1B,IArBI,KAAK,cAAgB,KAAK,mBAAqB,GAAQ,KAAK,oBAE/DnG,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI,EACrBkH,EAAOlH,GAAU,EAAI,GAEtB6D,EAASnB,EAAM,KACXmB,EAAS,GACZqD,EAAOlH,GAAU,EAAI,IAAO6D,EAClBA,EAAS,KACnBqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GACXA,EAAS,OACnBqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GAAU,EAC/BqD,EAAOlH,GAAU,EAAI6D,EAAS,MAE9BqD,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,UAAU/J,EAAU6D,CAAM,EACrC7D,GAAY,GAET0K,EAAQ,OACX,OAAS,CAAEhJ,EAAK6L,CAAU,IAAM7K,EAC/BoJ,EAAOpB,EAAQ,UAAUhJ,CAAG,CAAC,EAC7BoK,EAAOyB,CAAU,MAGlB,QAAS,CAAE7L,EAAK6L,CAAU,IAAM7K,EAC/BoJ,EAAOpK,CAAG,EACVoK,EAAOyB,CAAU,MAGb,CACN,QAASnK,EAAI,EAAG2C,EAAIuD,GAAW,OAAQlG,EAAI2C,EAAG3C,IAAK,CAClD,IAAIoK,EAAiBjE,GAAiBnG,CAAC,EACvC,GAAIV,aAAiB8K,EAAgB,CACpC,IAAIrJ,EAAYmF,GAAWlG,CAAC,EACxBoD,EAAMrC,EAAU,IAChBqC,GAAO,OACVA,EAAMrC,EAAU,QAAUA,EAAU,OAAO,KAAK,KAAMzB,CAAK,GACxD8D,EAAM,GACTU,EAAOlH,GAAU,EAAI,IAAOwG,EAClBA,EAAM,KAChBU,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAIwG,GACXA,EAAM,OAChBU,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAIwG,GAAO,EAC5BU,EAAOlH,GAAU,EAAIwG,EAAM,KACjBA,EAAM,KAChBU,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,UAAU/J,EAAUwG,CAAG,EAClCxG,GAAY,GAEbmE,EAAU,OAAO,KAAK,KAAMzB,EAAOoJ,EAAQG,EAAQ,EACnD,MACA,CACD,CACD,GAAIvJ,EAAM,OAAO,QAAQ,EAAG,CAC3B,GAAIoH,GAAiB,CACpB,IAAI1H,EAAQ,IAAI,MAAM,2CAA2C,EACjE,MAAAA,EAAM,mBAAqB,GACrBA,CACN,CACD8E,EAAOlH,GAAU,EAAI,IACrB,QAASyN,KAAS/K,EACjBoJ,EAAO2B,CAAK,EAEbvG,EAAOlH,GAAU,EAAI,IACrB,MACA,CACD,GAAI0C,EAAM,OAAO,aAAa,GAAKgL,GAAOhL,CAAK,EAAG,CACjD,IAAIN,EAAQ,IAAI,MAAM,gDAAgD,EACtE,MAAAA,EAAM,mBAAqB,GACrBA,CACN,CACD,GAAI,KAAK,WAAaM,EAAM,OAAQ,CACnC,MAAMiL,EAAOjL,EAAM,OAAQ,EAE3B,GAAIiL,IAASjL,EACZ,OAAOoJ,EAAO6B,CAAI,CACnB,CAGDL,GAAY5K,EAAO,CAACA,EAAM,cAAc,CACxC,CACD,SACS8J,IAAS,UACnBtF,EAAOlH,GAAU,EAAI0C,EAAQ,IAAO,YAC1B8J,IAAS,SAAU,CAC7B,GAAI9J,EAAS,OAAO,CAAC,GAAG,OAAO,EAAE,GAAMA,GAAS,EAE/CwE,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,aAAa/J,EAAU0C,CAAK,UAC7BA,EAAQ,EAAE,OAAO,CAAC,GAAG,OAAO,EAAE,IAAMA,EAAQ,EAEtDwE,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,aAAa/J,EAAU,CAAC0C,EAAQ,OAAO,CAAC,CAAC,UAGhD,KAAK,mBACRwE,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,WAAW/J,EAAU,OAAO0C,CAAK,CAAC,MAE7C,OAAM,IAAI,WAAWA,EAAQ,oGAAoG,EAGnI1C,GAAY,CAChB,SAAcwM,IAAS,YACnBtF,EAAOlH,GAAU,EAAI,QAErB,OAAM,IAAI,MAAM,iBAAmBwM,CAAI,CAExC,EAEKc,GAAc,KAAK,aAAe,GAAQ,KAAK,gBAAmBjK,GAAW,CAElF,IAAImI,EAAO,OAAO,KAAKnI,CAAM,EACzBuK,EAAO,OAAO,OAAOvK,CAAM,EAC3BQ,EAAS2H,EAAK,OAgBlB,GAfI3H,EAAS,GACZqD,EAAOlH,GAAU,EAAI,IAAO6D,EAClBA,EAAS,KACnBqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GACXA,EAAS,OACnBqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GAAU,EAC/BqD,EAAOlH,GAAU,EAAI6D,EAAS,MAE9BqD,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,UAAU/J,EAAU6D,CAAM,EACrC7D,GAAY,GAGT0K,EAAQ,OACX,QAAStH,EAAI,EAAGA,EAAIS,EAAQT,IAC3B0I,EAAOpB,EAAQ,UAAUc,EAAKpI,CAAC,CAAC,CAAC,EACjC0I,EAAO8B,EAAKxK,CAAC,CAAC,MAGf,SAASA,EAAI,EAAGA,EAAIS,EAAQT,IAC3B0I,EAAON,EAAKpI,CAAC,CAAC,EACd0I,EAAO8B,EAAKxK,CAAC,CAAC,CAGhB,EACD,CAACC,EAAQwK,IAAkB,CAC1B3G,EAAOlH,GAAU,EAAI,IACrB,IAAI8N,EAAe9N,EAAWmF,EAC9BnF,GAAY,EACZ,IAAIyC,EAAO,EACX,GAAIiI,EAAQ,OACX,QAAShJ,KAAO2B,GAAYwK,GAAiBxK,EAAO,eAAe3B,CAAG,KACrEoK,EAAOpB,EAAQ,UAAUhJ,CAAG,CAAC,EAC7BoK,EAAOzI,EAAO3B,CAAG,CAAC,EAClBe,SAGD,SAASf,KAAO2B,GAAYwK,GAAiBxK,EAAO,eAAe3B,CAAG,KACpEoK,EAAOpK,CAAG,EACVoK,EAAOzI,EAAO3B,CAAG,CAAC,EACnBe,KAGFyE,EAAO4G,IAAiB3I,CAAK,EAAI1C,GAAQ,EACzCyE,EAAO4G,EAAe3I,CAAK,EAAI1C,EAAO,GACtC,EACD,CAACY,EAAQwK,IAAkB,CAC1B,IAAIpC,EAAgBC,EAAanB,EAAW,cAAgBA,EAAW,YAAc,OAAO,OAAO,IAAI,GACnGwD,EAAiB,EACjBlK,EAAS,EACTmK,EACAxC,EACJ,GAAI,KAAK,OAAQ,CAChBA,EAAO,OAAO,KAAKnI,CAAM,EAAE,IAAI,GAAK,KAAK,UAAU,CAAC,CAAC,EACrDQ,EAAS2H,EAAK,OACd,QAASpI,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CAChC,IAAI1B,GAAM8J,EAAKpI,CAAC,EAChBqI,EAAiBC,EAAWhK,EAAG,EAC1B+J,IACJA,EAAiBC,EAAWhK,EAAG,EAAI,OAAO,OAAO,IAAI,EACrDqM,KAEDrC,EAAaD,CACb,CACL,KACI,SAAS/J,KAAO2B,GAAYwK,GAAiBxK,EAAO,eAAe3B,CAAG,KACrE+J,EAAiBC,EAAWhK,CAAG,EAC1B+J,IACAC,EAAWvB,CAAa,EAAI,UAC/B6D,EAAiBtC,EAAWvB,CAAa,EAAI,OAE9CsB,EAAiBC,EAAWhK,CAAG,EAAI,OAAO,OAAO,IAAI,EACrDqM,KAEDrC,EAAaD,EACb5H,KAGF,IAAIoK,EAAWvC,EAAWvB,CAAa,EACvC,GAAI8D,IAAa,OAChBA,GAAY,MACZ/G,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAKiO,GAAY,EAAK,IACvC/G,EAAOlH,GAAU,EAAIiO,EAAW,YAE3BzC,IACJA,EAAOE,EAAW,WAAaA,EAAW,SAAW,OAAO,KAAKrI,CAAM,IACpE2K,IAAmB,QACtBC,EAAW1D,EAAW,SACjB0D,IACJA,EAAW,EACX1D,EAAW,OAAS,GAEjB0D,GAAYrE,KACfW,EAAW,QAAU0D,EAAWrD,GAAuB,IAGxDqD,EAAWD,EAEZzD,EAAW0D,CAAQ,EAAIzC,EACnByC,EAAWrD,EAAqB,CACnC1D,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAKiO,GAAY,EAAK,IACvC/G,EAAOlH,GAAU,EAAIiO,EAAW,IAChCvC,EAAanB,EAAW,YACxB,QAASnH,EAAI,EAAGA,EAAIS,EAAQT,KACvBsI,EAAWvB,CAAa,IAAM,QAAcuB,EAAWvB,CAAa,EAAI,WAC3EuB,EAAWvB,CAAa,EAAI8D,GAC7BvC,EAAaA,EAAWF,EAAKpI,CAAC,CAAC,EAEhCsI,EAAWvB,CAAa,EAAI8D,EAAW,QACvC3D,EAAkB,EACvB,KAAW,CAaN,GAZAoB,EAAWvB,CAAa,EAAI8D,EAC5BlE,EAAW,UAAU/J,EAAU,UAAU,EACzCA,GAAY,EACR+N,IACH5C,IAAoBC,GAAuC2C,GAExD7C,EAAkB,QAAUtB,GAAiBgB,IAChDM,EAAkB,MAAK,EAAGf,CAAa,EAAI,QAC5Ce,EAAkB,KAAKQ,CAAU,EACjCE,EAAiB/H,EAAS,CAAC,EAC3BiI,EAAO,MAASmC,CAAQ,EACxBnC,EAAON,CAAI,EACPqC,IAAkB,KAAM,OAC5B,QAASnM,KAAO2B,GACXwK,GAAiBxK,EAAO,eAAe3B,CAAG,IAC7CoK,EAAOzI,EAAO3B,CAAG,CAAC,EACpB,MACA,CAOF,GALImC,EAAS,GACZqD,EAAOlH,GAAU,EAAI,IAAO6D,EAE5B+H,EAAiB/H,CAAM,EAEpBgK,IAAkB,KACtB,QAASnM,KAAO2B,GACXwK,GAAiBxK,EAAO,eAAe3B,CAAG,IAC7CoK,EAAOzI,EAAO3B,CAAG,CAAC,CACpB,EACKuK,GAAYjK,GAAQ,CACzB,IAAIkM,EACJ,GAAIlM,EAAM,SAAW,CAEpB,GAAKA,EAAMmD,EAAS0E,GACnB,MAAM,IAAI,MAAM,yDAAyD,EAC1EqE,EAAU,KAAK,IAAIrE,GAClB,KAAK,MAAM,KAAK,KAAK7H,EAAMmD,IAAUnD,EAAM,SAAY,KAAO,GAAI,OAAQ,EAAI,IAAM,EAAI,IAAM,CAC/F,MACAkM,GAAY,KAAK,IAAKlM,EAAMmD,GAAU,EAAG+B,EAAO,OAAS,CAAC,GAAK,IAAM,GAAM,GAC5E,IAAIiH,EAAY,IAAIzE,GAAkBwE,CAAO,EAC7C,OAAAnE,EAAa,IAAI,SAASoE,EAAU,OAAQ,EAAGD,CAAO,EAClDhH,EAAO,KACVA,EAAO,KAAKiH,EAAW,EAAGhJ,EAAOnD,CAAG,EAEpCmM,EAAU,IAAIjH,EAAO,MAAM/B,EAAOnD,CAAG,CAAC,EACvChC,GAAYmF,EACZA,EAAQ,EACR6E,EAAUmE,EAAU,OAAS,GACtBjH,EAASiH,CAChB,EACD,IAAIC,EAAiB,IACjBC,GAA0B,IAC9B,KAAK,iBAAmB,SAAS3L,EAAOnB,EAAS,CAChD,OAAO+M,GAAc5L,EAAOnB,EAASgN,CAAsB,CAC3D,EACD,KAAK,sBAAwB,SAAS7L,EAAOnB,EAAS,CACrD,OAAO+M,GAAc5L,EAAOnB,EAASiN,EAA2B,CAChE,EAED,SAAUD,EAAuBlL,EAAQoL,EAAmBC,EAAe,CAC1E,IAAIrB,EAAchK,EAAO,YACzB,GAAIgK,IAAgB,OAAQ,CAC3B,IAAIsB,EAAajE,EAAQ,aAAe,GACpCiE,EACHrB,GAAYjK,EAAQ,IAAI,EAExBuL,GAAkB,OAAO,KAAKvL,CAAM,EAAE,OAAQ,GAAI,EACnD,QAAS3B,KAAO2B,EAAQ,CACvB,IAAIX,EAAQW,EAAO3B,CAAG,EACjBiN,GAAY7C,EAAOpK,CAAG,EACvBgB,GAAS,OAAOA,GAAU,SACzB+L,EAAkB/M,CAAG,EACxB,MAAO6M,EAAuB7L,EAAO+L,EAAkB/M,CAAG,CAAC,EAE3D,MAAOmN,GAAUnM,EAAO+L,EAAmB/M,CAAG,EACzCoK,EAAOpJ,CAAK,CACnB,CACL,SAAc2K,IAAgB,MAAO,CACjC,IAAIxJ,EAASR,EAAO,OACpBuI,EAAiB/H,CAAM,EACvB,QAAST,EAAI,EAAGA,EAAIS,EAAQT,IAAK,CAChC,IAAIV,EAAQW,EAAOD,CAAC,EAChBV,IAAU,OAAOA,GAAU,UAAY1C,EAAWmF,EAAQiJ,GACzDK,EAAkB,QACrB,MAAOF,EAAuB7L,EAAO+L,EAAkB,OAAO,EAE9D,MAAOI,GAAUnM,EAAO+L,EAAmB,SAAS,EAC/C3C,EAAOpJ,CAAK,CACnB,CACD,SAAUW,EAAO,OAAO,QAAQ,EAAG,CACnC6D,EAAOlH,GAAU,EAAI,IACrB,QAAS0C,KAASW,EACbX,IAAU,OAAOA,GAAU,UAAY1C,EAAWmF,EAAQiJ,GACzDK,EAAkB,QACrB,MAAOF,EAAuB7L,EAAO+L,EAAkB,OAAO,EAE9D,MAAOI,GAAUnM,EAAO+L,EAAmB,SAAS,EAC/C3C,EAAOpJ,CAAK,EAEpBwE,EAAOlH,GAAU,EAAI,GACzB,MAAc0N,GAAOrK,CAAM,GACvBuL,GAAkBvL,EAAO,KAAM,EAAI,EACnC,MAAM6D,EAAO,SAAS/B,EAAOnF,CAAQ,EACrC,MAAMqD,EACNyL,MACUzL,EAAO,OAAO,aAAa,GACrC6D,EAAOlH,GAAU,EAAI,IACrB,MAAMkH,EAAO,SAAS/B,EAAOnF,CAAQ,EACrC,MAAMqD,EACNyL,KACA5H,EAAOlH,GAAU,EAAI,KAErB8L,EAAOzI,CAAM,EAEVqL,GAAiB1O,EAAWmF,EAAO,MAAM+B,EAAO,SAAS/B,EAAOnF,CAAQ,EACnEA,EAAWmF,EAAQiJ,IAC3B,MAAMlH,EAAO,SAAS/B,EAAOnF,CAAQ,EACrC8O,KAED,CACD,SAAUD,GAAUnM,EAAO+L,EAAmB/M,EAAK,CAClD,IAAIqN,EAAU/O,EAAWmF,EACzB,GAAI,CACH2G,EAAOpJ,CAAK,EACR1C,EAAWmF,EAAQiJ,IACtB,MAAMlH,EAAO,SAAS/B,EAAOnF,CAAQ,EACrC8O,KAED,OAAQ1M,EAAO,CACf,GAAIA,EAAM,mBACTqM,EAAkB/M,CAAG,EAAI,GACzB1B,EAAWmF,EAAQ4J,EACnB,MAAOR,EAAuB,KAAK,KAAM7L,EAAO+L,EAAkB/M,CAAG,CAAC,MAChE,OAAMU,CACb,CACD,CACD,SAAS0M,IAAkB,CAC1BV,EAAiBC,GACjB3D,EAAQ,OAAO,KAAMqB,EAAiB,CACtC,CACD,SAASuC,GAAc5L,EAAOnB,EAASyN,EAAgB,CAKtD,OAJIzN,GAAWA,EAAQ,eACtB6M,EAAiBC,GAA0B9M,EAAQ,eAEnD6M,EAAiB,IACd1L,GAAS,OAAOA,GAAU,UAC7BgI,EAAQ,OAAO,KAAMqB,EAAiB,EAC/BiD,EAAetM,EAAOgI,EAAQ,oBAAsBA,EAAQ,kBAAoB,CAAA,GAAK,EAAI,GAE1F,CAACA,EAAQ,OAAOhI,CAAK,CAAC,CAC7B,CAED,eAAgB8L,GAA4B9L,EAAO+L,EAAmB,CACrE,QAASQ,KAAgBV,EAAuB7L,EAAO+L,EAAmB,EAAI,EAAG,CAChF,IAAIpB,EAAc4B,EAAa,YAC/B,GAAI5B,IAAgB1D,IAAa0D,IAAgB,WAChD,MAAM4B,UACEvB,GAAOuB,CAAY,EAAG,CAC9B,IAAIC,EAASD,EAAa,OAAQ,EAAC,UAAS,EACxCE,EACJ,KAAO,EAAEA,EAAO,MAAMD,EAAO,KAAI,GAAI,MACpC,MAAMC,EAAK,KAEZ,SAAUF,EAAa,OAAO,aAAa,EAC3C,cAAeG,KAAcH,EAC5BH,KACIM,EACH,MAAOZ,GAA4BY,EAAYX,EAAkB,QAAUA,EAAkB,MAAQ,CAAE,EAAC,EACpG,MAAM/D,EAAQ,OAAO0E,CAAU,OAGrC,MAAMH,CAEP,CACD,CACD,CACD,UAAUtI,EAAQ,CAEjBO,EAASP,EACToD,EAAa,IAAI,SAAS7C,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAC7ElH,EAAW,CACX,CACD,iBAAkB,CACb,KAAK,aACR,KAAK,WAAa,CAAE,GACjB,KAAK,eACR,KAAK,aAAe,OACrB,CACD,kBAAmB,CAClB,IAAIqP,EAAc,KAAK,eAAiB,EACxC,KAAK,cAAgBA,EAAc,EACnC,IAAIC,EAAiB,KAAK,WAAW,MAAM,CAAC,EACxC/G,EAAa,IAAIgH,GAAWD,EAAgB,KAAK,aAAc,KAAK,aAAa,EACjFE,EAAc,KAAK,WAAWjH,EAChCkH,IAAmBA,GAAkBA,EAAe,SAAW,IAAMJ,CAAW,EAClF,OAAIG,IAAgB,IAEnBjH,EAAa,KAAK,UAAS,GAAM,CAAE,EACnC,KAAK,WAAaA,EAAW,YAAc,CAAE,EAC7C,KAAK,aAAeA,EAAW,aAC/B,KAAK,cAAgBA,EAAW,QAChC,KAAK,WAAW,OAAS,KAAK,WAAW,QAGzC+G,EAAe,QAAQ,CAAC3L,EAAWP,IAAM,KAAK,WAAWA,CAAC,EAAIO,CAAS,EAGjE6L,CACP,CACF,CACA,SAASZ,GAAkB/K,EAAQ6L,EAAY,CAC1C7L,EAAS,GACZqD,EAAOlH,GAAU,EAAI0P,EAAa7L,EAC1BA,EAAS,KACjBqD,EAAOlH,GAAU,EAAI0P,EAAa,GAClCxI,EAAOlH,GAAU,EAAI6D,GACXA,EAAS,OACnBqD,EAAOlH,GAAU,EAAI0P,EAAa,GAClCxI,EAAOlH,GAAU,EAAI6D,GAAU,EAC/BqD,EAAOlH,GAAU,EAAI6D,EAAS,MAE9BqD,EAAOlH,GAAU,EAAI0P,EAAa,GAClC3F,EAAW,UAAU/J,EAAU6D,CAAM,EACrC7D,GAAY,EAGd,CACA,MAAMuP,EAAW,CAChB,YAAYhF,EAAYhI,EAAQoN,EAAS,CACxC,KAAK,WAAapF,EAClB,KAAK,aAAehI,EACpB,KAAK,QAAUoN,CACf,CACF,CAEA,SAAS/D,EAAiB/H,EAAQ,CAC7BA,EAAS,GACZqD,EAAOlH,GAAU,EAAI,IAAO6D,EACpBA,EAAS,KACjBqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GACXA,EAAS,OACnBqD,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI6D,GAAU,EAC/BqD,EAAOlH,GAAU,EAAI6D,EAAS,MAE9BqD,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,UAAU/J,EAAU6D,CAAM,EACrC7D,GAAY,EAEd,CAEA,MAAM4P,GAAkB,OAAO,KAAS,IAAc,UAAU,CAAA,EAAK,KACrE,SAASlC,GAAOrK,EAAQ,CACvB,GAAIA,aAAkBuM,GACrB,MAAO,GACR,IAAIpJ,EAAMnD,EAAO,OAAO,WAAW,EACnC,OAAOmD,IAAQ,QAAUA,IAAQ,MAClC,CACA,SAASmF,GAAsBjJ,EAAO1B,EAAc,CACnD,OAAO,OAAO0B,EAAK,CAClB,IAAK,SACJ,GAAIA,EAAM,OAAS,EAAG,CACrB,GAAI1B,EAAa,UAAU0B,CAAK,EAAI,IAAM1B,EAAa,OAAO,QAAUA,EAAa,UACpF,OACD,IAAI6O,EAAe7O,EAAa,IAAI0B,CAAK,EACzC,GAAImN,EACC,EAAEA,EAAa,OAAS,GAC3B7O,EAAa,OAAO,KAAK0B,CAAK,UAG/B1B,EAAa,IAAI0B,EAAO,CACvB,MAAO,CACb,CAAM,EACG1B,EAAa,qBAAsB,CACtC,IAAIuL,EAASvL,EAAa,qBAAqB,IAAI0B,CAAK,EACpD6J,EACHA,EAAO,QAEPvL,EAAa,qBAAqB,IAAI0B,EAAO,CAC5C,MAAO,CACf,CAAQ,CACF,CAEF,CACD,MACD,IAAK,SACJ,GAAIA,EACH,GAAIA,aAAiB,MACpB,QAASU,EAAI,EAAG2C,EAAIrD,EAAM,OAAQU,EAAI2C,EAAG3C,IACxCuI,GAAsBjJ,EAAMU,CAAC,EAAGpC,CAAY,MAGvC,CACN,IAAI8O,EAAc,CAAC9O,EAAa,QAAQ,WACxC,QAASU,KAAOgB,EACXA,EAAM,eAAehB,CAAG,IACvBoO,GACHnE,GAAsBjK,EAAKV,CAAY,EACxC2K,GAAsBjJ,EAAMhB,CAAG,EAAGV,CAAY,EAGhD,CAEF,MACD,IAAK,WAAY,QAAQ,IAAI0B,CAAK,CAClC,CACF,CACA,MAAM6E,GAAwB,IAAI,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,GAAK,EAChFgC,GAAmB,CAAE,KAAM,IAAK,MAAO,OAAQlF,EAAK,YACnD,WAAY,kBAAmB,YAAa,YAC5C,OAAO,eAAkB,IAAc,UAAW,CAAA,EAAK,eAAgB,UAAW,WAAY,WAC9F,OAAO,cAAiB,IAAc,UAAW,CAAA,EAAK,cACtD,aAAc,aAAckL,EAAY,EAGzCjG,GAAa,CAAC,CACb,IAAK,EACL,OAAOyG,EAAMjE,EAAQ,CACpB,IAAIkE,EAAUD,EAAK,QAAO,EAAK,KAC1B,KAAK,gBAAkBA,EAAK,gBAAe,IAAO,IAAMC,GAAW,GAAKA,EAAU,YAEtF9I,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,UAAU/J,EAAUgQ,CAAO,EACtChQ,GAAY,IAGZkH,EAAOlH,GAAU,EAAI,IACrB+J,EAAW,WAAW/J,EAAUgQ,CAAO,EACvChQ,GAAY,EAEb,CACF,EAAG,CACF,IAAK,IACL,OAAOiQ,EAAKnE,EAAQ,CACnB,IAAI3I,EAAQ,MAAM,KAAK8M,CAAG,EAC1BnE,EAAO3I,CAAK,CACZ,CACF,EAAG,CACF,IAAK,GACL,OAAOf,EAAO0J,EAAQ,CACrBA,EAAO,CAAE1J,EAAM,KAAMA,EAAM,OAAO,CAAE,CACpC,CACF,EAAG,CACF,IAAK,GACL,OAAO8N,EAAOpE,EAAQ,CACrBA,EAAO,CAAE,SAAUoE,EAAM,OAAQA,EAAM,MAAO,CAC9C,CACF,EAAG,CACF,OAAO1J,EAAK,CACX,OAAOA,EAAI,GACX,EACD,OAAOA,EAAKsF,EAAQ,CACnBA,EAAOtF,EAAI,KAAK,CAChB,CACF,EAAG,CACF,OAAO2J,EAAarE,EAAQG,EAAU,CACrCmE,GAAYD,EAAalE,CAAQ,CACjC,CACF,EAAG,CACF,OAAOoE,EAAY,CAClB,GAAIA,EAAW,cAAgB,aAC1B,KAAK,eAAiB5G,IAAiB,KAAK,gBAAkB,IACjE,MAAO,GAET,EACD,OAAO4G,EAAYvE,EAAQG,EAAU,CACpCmE,GAAYC,EAAYpE,CAAQ,CAChC,CACF,EACCqE,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACvBA,EAAkB,GAAI,CAAC,EACxB,CACC,OAAO/H,EAAYuD,EAAQ,CAC1B,IAAI9K,EAAeuH,EAAW,cAAgB,CAAE,EAC5C8B,EAAmB9B,EAAW,YAAc,CAAE,EAClD,GAAIvH,EAAa,OAAO,OAAS,EAAG,CACnCkG,EAAOlH,GAAU,EAAI,IACrBkH,EAAOlH,GAAU,EAAI,GACrB4L,EAAiB,CAAC,EAClB,IAAIC,EAAc7K,EAAa,OAC/B8K,EAAOD,CAAW,EAClBD,EAAiB,CAAC,EAClBA,EAAiB,CAAC,EAClB,gBAAkB,OAAO,OAAO,uBAAyB,IAAI,EAC7D,QAASxI,EAAI,EAAG2C,EAAI8F,EAAY,OAAQzI,EAAI2C,EAAG3C,IAC9C,gBAAgByI,EAAYzI,CAAC,CAAC,EAAIA,CAEnC,CACD,GAAIiH,EAAkB,CACrBN,EAAW,UAAU/J,EAAU,UAAU,EACzCA,GAAY,EACZ,IAAIuQ,EAAclG,EAAiB,MAAM,CAAC,EAC1CkG,EAAY,QAAQ,KAAM,EAC1BA,EAAY,KAAK,IAAIlM,EAAIkE,EAAW,QAAS,UAAU,CAAC,EACxDuD,EAAOyE,CAAW,CAClB,MACAzE,EAAO,IAAIzH,EAAIkE,EAAW,QAAS,UAAU,CAAC,CAC9C,CACH,CAAE,EACF,SAAS+H,EAAkB9J,EAAK/D,EAAM,CACrC,MAAI,CAAC8E,IAAyB9E,EAAO,IACpC+D,GAAO,GACD,CACN,IAAKA,EACL,OAAQ,SAAwB6J,EAAYvE,EAAQ,CACnD,IAAIjI,EAASwM,EAAW,WACpBG,EAASH,EAAW,YAAc,EAClC1J,EAAS0J,EAAW,QAAUA,EAClCvE,EAAOrC,GAAgBD,GAAO,KAAK7C,EAAQ6J,EAAQ3M,CAAM,EACxD,IAAI,WAAW8C,EAAQ6J,EAAQ3M,CAAM,CAAC,CACvC,CACD,CACF,CACA,SAASuM,GAAYzJ,EAAQsF,EAAU,CACtC,IAAIpI,EAAS8C,EAAO,WAChB9C,EAAS,GACZqD,EAAOlH,GAAU,EAAI,GAAO6D,EAClBA,EAAS,KACnBqD,EAAOlH,GAAU,EAAI,GACrBkH,EAAOlH,GAAU,EAAI6D,GACXA,EAAS,OACnBqD,EAAOlH,GAAU,EAAI,GACrBkH,EAAOlH,GAAU,EAAI6D,GAAU,EAC/BqD,EAAOlH,GAAU,EAAI6D,EAAS,MAE9BqD,EAAOlH,GAAU,EAAI,GACrB+J,EAAW,UAAU/J,EAAU6D,CAAM,EACrC7D,GAAY,GAETA,EAAW6D,GAAUqD,EAAO,QAC/B+E,EAASjM,EAAW6D,CAAM,EAI3BqD,EAAO,IAAIP,EAAO,OAASA,EAAS,IAAI,WAAWA,CAAM,EAAG3G,CAAQ,EACpEA,GAAY6D,CACb,CAEA,SAASsI,GAAUD,EAAYkB,EAAa,CAE3C,IAAIqD,EACAC,EAAiBtD,EAAY,OAAS,EACtCuD,EAAUzE,EAAW,OAASwE,EAClCtD,EAAY,KAAK,CAAC,EAAG7H,IAAM,EAAE,OAASA,EAAE,OAAS,EAAI,EAAE,EACvD,QAASxB,EAAK,EAAGA,EAAKqJ,EAAY,OAAQrJ,IAAM,CAC/C,IAAIoJ,EAAUC,EAAYrJ,CAAE,EAC5BoJ,EAAQ,GAAKpJ,EACb,QAAS/D,KAAYmN,EAAQ,WAC5BjB,EAAWlM,GAAU,EAAI+D,GAAM,EAC/BmI,EAAWlM,CAAQ,EAAI+D,EAAK,GAE7B,CACD,KAAO0M,EAASrD,EAAY,OAAO,CAClC,IAAIoD,EAASC,EAAO,OACpBvE,EAAW,WAAWsE,EAASE,EAAgBF,EAAQG,CAAO,EAC9DD,GAAkB,EAClB,IAAI1Q,EAAWwQ,EAASE,EACxBxE,EAAWlM,GAAU,EAAI,IACzBkM,EAAWlM,GAAU,EAAI,GACzB2Q,EAAUH,CACV,CACD,OAAOtE,CACR,CACA,SAASF,GAAa7G,EAAO2G,EAAQ,CACpC/B,EAAW,UAAUnJ,EAAe,SAAWuE,EAAOnF,EAAWY,EAAe,SAAWuE,EAAQ,CAAC,EACpG,IAAIyL,EAAehQ,EACnBA,EAAiB,KACjBkL,EAAO8E,EAAa,CAAC,CAAC,EACtB9E,EAAO8E,EAAa,CAAC,CAAC,CACvB,CAWA,IAAIC,GAAiB,IAAIzG,GAAQ,CAAE,WAAY,EAAK,CAAE,EAChCyG,GAAe,OACLA,GAAe,iBACVA,GAAe,sBAI7C,MAAMvF,GAAoB,IACpBe,GAAoB,KACpBN,GAAoB","x_google_ignoreList":[0,1]}